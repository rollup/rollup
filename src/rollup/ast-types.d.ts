// This file is generated by scripts/generate-ast-types.ts.
// Do not edit this file directly.

export interface BaseNode {
	end: number;
	start: number;
}

export type AnnotationType = 'pure' | 'noSideEffects';

interface Annotation extends BaseNode {
	type: AnnotationType;
}

export interface PanicError extends BaseNode {
	type: 'PanicError';
	message: string;
}

export interface ParseError extends BaseNode {
	type: 'ParseError';
	message: string;
}

export interface ArrayExpression extends BaseNode {
	type: 'ArrayExpression';
	elements: readonly (Expression | SpreadElement | null)[];
}

export interface ArrayPattern extends BaseNode {
	type: 'ArrayPattern';
	elements: readonly (DestructuringPattern | null)[];
}

export interface ArrowFunctionExpression extends BaseNode {
	type: 'ArrowFunctionExpression';
	annotations?: readonly Annotation[];
	params: readonly Parameter[];
	body: BlockStatement | Expression;
	id: null;
	async: boolean;
	expression: boolean;
	generator: boolean;
}

export interface AssignmentExpression extends BaseNode {
	type: 'AssignmentExpression';
	operator:
		| '='
		| '+='
		| '-='
		| '*='
		| '/='
		| '%='
		| '**='
		| '<<='
		| '>>='
		| '>>>='
		| '|='
		| '^='
		| '&='
		| '||='
		| '&&='
		| '??=';
	left: DestructuringPattern;
	right: Expression;
}

export interface AssignmentPattern extends BaseNode {
	type: 'AssignmentPattern';
	left: BindingPattern;
	right: Expression;
}

export interface AwaitExpression extends BaseNode {
	type: 'AwaitExpression';
	argument: Expression;
}

export interface BinaryExpression extends BaseNode {
	type: 'BinaryExpression';
	operator:
		| '=='
		| '!='
		| '==='
		| '!=='
		| '<'
		| '<='
		| '>'
		| '>='
		| '<<'
		| '>>'
		| '>>>'
		| '+'
		| '-'
		| '*'
		| '/'
		| '%'
		| '**'
		| '^'
		| '&'
		| '|'
		| 'in'
		| 'instanceof';
	left: Expression | PrivateIdentifier;
	right: Expression;
}

export interface BlockStatement extends BaseNode {
	type: 'BlockStatement';
	body: readonly Statement[];
}

export interface BreakStatement extends BaseNode {
	type: 'BreakStatement';
	label: Identifier | null;
}

export interface CallExpression extends BaseNode {
	type: 'CallExpression';
	annotations?: readonly Annotation[];
	callee: Expression | Super;
	arguments: readonly (Expression | SpreadElement)[];
	optional: boolean;
}

export interface CatchClause extends BaseNode {
	type: 'CatchClause';
	param: BindingPattern | null;
	body: BlockStatement;
}

export interface ChainExpression extends BaseNode {
	type: 'ChainExpression';
	expression: CallExpression | MemberExpression;
}

export interface ClassBody extends BaseNode {
	type: 'ClassBody';
	body: readonly (MethodDefinition | PropertyDefinition | StaticBlock)[];
}

export interface ClassDeclaration extends BaseNode {
	type: 'ClassDeclaration';
	decorators: readonly Decorator[];
	id: Identifier | null;
	superClass: Expression | null;
	body: ClassBody;
}

export interface ClassExpression extends BaseNode {
	type: 'ClassExpression';
	decorators: readonly Decorator[];
	id: Identifier | null;
	superClass: Expression | null;
	body: ClassBody;
}

export interface ConditionalExpression extends BaseNode {
	type: 'ConditionalExpression';
	test: Expression;
	consequent: Expression;
	alternate: Expression;
}

export interface ContinueStatement extends BaseNode {
	type: 'ContinueStatement';
	label: Identifier | null;
}

export interface DebuggerStatement extends BaseNode {
	type: 'DebuggerStatement';
}

export interface Decorator extends BaseNode {
	type: 'Decorator';
	expression: Expression;
}

export interface Directive extends BaseNode {
	type: 'ExpressionStatement';
	directive: string;
	expression: LiteralString;
}

export interface DoWhileStatement extends BaseNode {
	type: 'DoWhileStatement';
	body: Statement;
	test: Expression;
}

export interface EmptyStatement extends BaseNode {
	type: 'EmptyStatement';
}

export interface ExportAllDeclaration extends BaseNode {
	type: 'ExportAllDeclaration';
	exported: Identifier | null;
	source: LiteralString;
	attributes: readonly ImportAttribute[];
}

export interface ExportDefaultDeclaration extends BaseNode {
	type: 'ExportDefaultDeclaration';
	declaration: FunctionDeclaration | ClassDeclaration | Expression;
}

export interface ExportNamedDeclaration extends BaseNode {
	type: 'ExportNamedDeclaration';
	specifiers: readonly ExportSpecifier[];
	source: Literal | null;
	attributes: readonly ImportAttribute[];
	declaration: FunctionDeclaration | VariableDeclaration | ClassDeclaration | null;
}

export interface ExportSpecifier extends BaseNode {
	type: 'ExportSpecifier';
	local: Identifier | LiteralString;
	exported: Identifier | LiteralString;
}

export interface ExpressionStatement extends BaseNode {
	type: 'ExpressionStatement';
	expression: Expression;
}

export interface ForInStatement extends BaseNode {
	type: 'ForInStatement';
	left: VariableDeclaration | DestructuringPattern;
	right: Expression;
	body: Statement;
}

export interface ForOfStatement extends BaseNode {
	type: 'ForOfStatement';
	left: VariableDeclaration | DestructuringPattern;
	right: Expression;
	body: Statement;
	await: boolean;
}

export interface ForStatement extends BaseNode {
	type: 'ForStatement';
	init: Expression | VariableDeclaration | null;
	test: Expression | null;
	update: Expression | null;
	body: Statement;
}

export interface FunctionDeclaration extends BaseNode {
	type: 'FunctionDeclaration';
	annotations?: readonly Annotation[];
	id: Identifier | null;
	params: readonly Parameter[];
	body: BlockStatement;
	expression: false;
	async: boolean;
	generator: boolean;
}

export interface FunctionExpression extends BaseNode {
	type: 'FunctionExpression';
	annotations?: readonly Annotation[];
	id: Identifier | null;
	params: readonly Parameter[];
	body: BlockStatement;
	expression: false;
	async: boolean;
	generator: boolean;
}

export interface Identifier extends BaseNode {
	type: 'Identifier';
	name: string;
}

export interface IfStatement extends BaseNode {
	type: 'IfStatement';
	test: Expression;
	consequent: Statement;
	alternate: Statement | null;
}

export interface ImportAttribute extends BaseNode {
	type: 'ImportAttribute';
	key: Identifier | Literal;
	value: Literal;
}

export interface ImportDeclaration extends BaseNode {
	type: 'ImportDeclaration';
	specifiers: readonly (ImportDefaultSpecifier | ImportNamespaceSpecifier | ImportSpecifier)[];
	source: LiteralString;
	attributes: readonly ImportAttribute[];
}

export interface ImportDefaultSpecifier extends BaseNode {
	type: 'ImportDefaultSpecifier';
	local: Identifier;
}

export interface ImportExpression extends BaseNode {
	type: 'ImportExpression';
	source: Expression;
	options: Expression | null;
}

export interface ImportNamespaceSpecifier extends BaseNode {
	type: 'ImportNamespaceSpecifier';
	local: Identifier;
}

export interface ImportSpecifier extends BaseNode {
	type: 'ImportSpecifier';
	imported: Identifier | Literal;
	local: Identifier;
}

export interface JSXAttribute extends BaseNode {
	type: 'JSXAttribute';
	name: JSXIdentifier | JSXNamespacedName;
	value: JSXElement | JSXExpressionContainer | JSXSpreadChild | Literal | null;
}

export interface JSXClosingElement extends BaseNode {
	type: 'JSXClosingElement';
	name: JSXTagNameExpression;
}

export interface JSXClosingFragment extends BaseNode {
	type: 'JSXClosingFragment';
}

export interface JSXElement extends BaseNode {
	type: 'JSXElement';
	openingElement: JSXOpeningElement;
	children: readonly JSXChild[];
	closingElement: JSXClosingElement | null;
}

export interface JSXEmptyExpression extends BaseNode {
	type: 'JSXEmptyExpression';
}

export interface JSXExpressionContainer extends BaseNode {
	type: 'JSXExpressionContainer';
	expression: Expression | JSXEmptyExpression;
}

export interface JSXFragment extends BaseNode {
	type: 'JSXFragment';
	openingFragment: JSXOpeningFragment;
	children: readonly JSXChild[];
	closingFragment: JSXClosingFragment;
}

export interface JSXIdentifier extends BaseNode {
	type: 'JSXIdentifier';
	name: string;
}

export interface JSXMemberExpression extends BaseNode {
	type: 'JSXMemberExpression';
	object: JSXTagNameExpression;
	property: JSXIdentifier;
}

export interface JSXNamespacedName extends BaseNode {
	type: 'JSXNamespacedName';
	namespace: JSXIdentifier;
	name: JSXIdentifier;
}

export interface JSXOpeningElement extends BaseNode {
	type: 'JSXOpeningElement';
	name: JSXTagNameExpression;
	attributes: readonly (JSXAttribute | JSXSpreadAttribute)[];
	selfClosing: boolean;
}

export interface JSXOpeningFragment extends BaseNode {
	type: 'JSXOpeningFragment';
	attributes: never[];
	selfClosing: false;
}

export interface JSXSpreadAttribute extends BaseNode {
	type: 'JSXSpreadAttribute';
	argument: Expression;
}

export interface JSXSpreadChild extends BaseNode {
	type: 'JSXSpreadChild';
	expression: Expression | JSXEmptyExpression;
}

export interface JSXText extends BaseNode {
	type: 'JSXText';
	value: string;
	raw: string;
}

export interface LabeledStatement extends BaseNode {
	type: 'LabeledStatement';
	label: Identifier;
	body: Statement;
}

export interface LiteralBigInt extends BaseNode {
	type: 'Literal';
	bigint: string;
	raw: string;
	value: bigint;
}

export interface LiteralBoolean extends BaseNode {
	type: 'Literal';
	raw: string;
	value: boolean;
}

export interface LiteralNull extends BaseNode {
	type: 'Literal';
	value: null;
	raw: 'null';
}

export interface LiteralNumber extends BaseNode {
	type: 'Literal';
	raw?: string;
	value: number;
}

export interface LiteralRegExp extends BaseNode {
	type: 'Literal';
	raw: string;
	regex: { flags: string; pattern: string };
	value: RegExp;
}

export interface LiteralString extends BaseNode {
	type: 'Literal';
	value: string;
	raw?: string;
}

export interface LogicalExpression extends BaseNode {
	type: 'LogicalExpression';
	operator: '||' | '&&' | '??';
	left: Expression | PrivateIdentifier;
	right: Expression;
}

export interface MemberExpression extends BaseNode {
	type: 'MemberExpression';
	object: Expression | Super;
	property: Expression | PrivateIdentifier;
	computed: boolean;
	optional: boolean;
}

export interface MetaProperty extends BaseNode {
	type: 'MetaProperty';
	meta: Identifier;
	property: Identifier;
}

export interface MethodDefinition extends BaseNode {
	type: 'MethodDefinition';
	decorators: readonly Decorator[];
	key: Expression | PrivateIdentifier;
	value: FunctionExpression;
	kind: 'constructor' | 'method' | 'get' | 'set';
	static: boolean;
	computed: boolean;
}

export interface NewExpression extends BaseNode {
	type: 'NewExpression';
	annotations?: readonly Annotation[];
	callee: Expression;
	arguments: readonly (Expression | SpreadElement)[];
}

export interface ObjectExpression extends BaseNode {
	type: 'ObjectExpression';
	properties: readonly (Property | SpreadElement)[];
}

export interface ObjectPattern extends BaseNode {
	type: 'ObjectPattern';
	properties: readonly (Property | RestElement)[];
}

export interface PrivateIdentifier extends BaseNode {
	type: 'PrivateIdentifier';
	name: string;
}

export interface Program extends BaseNode {
	type: 'Program';
	body: readonly (Statement | Directive | ModuleDeclaration)[];
	invalidAnnotations?: readonly Annotation[];
	sourceType: 'module';
}

export interface Property extends BaseNode {
	type: 'Property';
	key: Expression;
	value: Expression | DestructuringPattern;
	kind: 'init' | 'get' | 'set';
	method: boolean;
	shorthand: boolean;
	computed: boolean;
}

export interface PropertyDefinition extends BaseNode {
	type: 'PropertyDefinition';
	decorators: readonly Decorator[];
	key: Expression | PrivateIdentifier;
	value: Expression | null;
	static: boolean;
	computed: boolean;
}

export interface RestElement extends BaseNode {
	type: 'RestElement';
	argument: DestructuringPattern;
}

export interface ReturnStatement extends BaseNode {
	type: 'ReturnStatement';
	argument: Expression | null;
}

export interface SequenceExpression extends BaseNode {
	type: 'SequenceExpression';
	expressions: readonly Expression[];
}

export interface SpreadElement extends BaseNode {
	type: 'SpreadElement';
	argument: Expression;
}

export interface StaticBlock extends BaseNode {
	type: 'StaticBlock';
	body: readonly Statement[];
}

export interface Super extends BaseNode {
	type: 'Super';
}

export interface SwitchCase extends BaseNode {
	type: 'SwitchCase';
	test: Expression | null;
	consequent: readonly Statement[];
}

export interface SwitchStatement extends BaseNode {
	type: 'SwitchStatement';
	discriminant: Expression;
	cases: readonly SwitchCase[];
}

export interface TaggedTemplateExpression extends BaseNode {
	type: 'TaggedTemplateExpression';
	tag: Expression;
	quasi: TemplateLiteral;
}

export interface TemplateElement extends BaseNode {
	type: 'TemplateElement';
	value: { cooked?: string; raw: string };
	tail: boolean;
}

export interface TemplateLiteral extends BaseNode {
	type: 'TemplateLiteral';
	quasis: readonly TemplateElement[];
	expressions: readonly Expression[];
}

export interface ThisExpression extends BaseNode {
	type: 'ThisExpression';
}

export interface ThrowStatement extends BaseNode {
	type: 'ThrowStatement';
	argument: Expression;
}

export interface TryStatement extends BaseNode {
	type: 'TryStatement';
	block: BlockStatement;
	handler: CatchClause | null;
	finalizer: BlockStatement | null;
}

export interface UnaryExpression extends BaseNode {
	type: 'UnaryExpression';
	operator: '-' | '+' | '!' | '~' | 'typeof' | 'void' | 'delete';
	argument: Expression;
	prefix: true;
}

export interface UpdateExpression extends BaseNode {
	type: 'UpdateExpression';
	operator: '++' | '--';
	argument: Expression;
	prefix: boolean;
}

export interface VariableDeclaration extends BaseNode {
	type: 'VariableDeclaration';
	kind: 'var' | 'let' | 'const' | 'using' | 'await using';
	declarations: readonly VariableDeclarator[];
}

export interface VariableDeclarator extends BaseNode {
	type: 'VariableDeclarator';
	id: BindingPattern;
	init: Expression | null;
}

export interface WhileStatement extends BaseNode {
	type: 'WhileStatement';
	test: Expression;
	body: Statement;
}

export interface YieldExpression extends BaseNode {
	type: 'YieldExpression';
	argument: Expression | null;
	delegate: boolean;
}

export type BindingPattern = Identifier | ArrayPattern | ObjectPattern;

export type DestructuringPattern =
	| AssignmentPattern
	| BindingPattern
	| MemberExpression
	| RestElement;

export type Expression =
	| ArrayExpression
	| ArrowFunctionExpression
	| AssignmentExpression
	| AwaitExpression
	| BinaryExpression
	| CallExpression
	| ChainExpression
	| ClassExpression
	| ConditionalExpression
	| FunctionExpression
	| Identifier
	| ImportExpression
	| Literal
	| LogicalExpression
	| MemberExpression
	| MetaProperty
	| NewExpression
	| ObjectExpression
	| SequenceExpression
	| TaggedTemplateExpression
	| TemplateLiteral
	| ThisExpression
	| UnaryExpression
	| UpdateExpression
	| YieldExpression;

export type JSXChild = JSXElement | JSXExpressionContainer | JSXSpreadChild | JSXFragment | JSXText;

export type JSXTagNameExpression = JSXMemberExpression | JSXIdentifier | JSXNamespacedName;

export type Literal =
	| LiteralBigInt
	| LiteralBoolean
	| LiteralNull
	| LiteralNumber
	| LiteralRegExp
	| LiteralString;

export type ModuleDeclaration =
	| ExportAllDeclaration
	| ExportDefaultDeclaration
	| ExportNamedDeclaration
	| ImportDeclaration;

export type Parameter = BindingPattern | AssignmentPattern | RestElement;

export type Statement =
	| BlockStatement
	| BreakStatement
	| ClassDeclaration
	| ContinueStatement
	| DebuggerStatement
	| DoWhileStatement
	| EmptyStatement
	| ExpressionStatement
	| ForInStatement
	| ForOfStatement
	| ForStatement
	| FunctionDeclaration
	| IfStatement
	| LabeledStatement
	| ReturnStatement
	| StaticBlock
	| SwitchStatement
	| ThrowStatement
	| TryStatement
	| VariableDeclaration
	| WhileStatement;

export type AstNode =
	| PanicError
	| ParseError
	| ArrayExpression
	| ArrayPattern
	| ArrowFunctionExpression
	| AssignmentExpression
	| AssignmentPattern
	| AwaitExpression
	| BinaryExpression
	| BlockStatement
	| BreakStatement
	| CallExpression
	| CatchClause
	| ChainExpression
	| ClassBody
	| ClassDeclaration
	| ClassExpression
	| ConditionalExpression
	| ContinueStatement
	| DebuggerStatement
	| Decorator
	| Directive
	| DoWhileStatement
	| EmptyStatement
	| ExportAllDeclaration
	| ExportDefaultDeclaration
	| ExportNamedDeclaration
	| ExportSpecifier
	| ExpressionStatement
	| ForInStatement
	| ForOfStatement
	| ForStatement
	| FunctionDeclaration
	| FunctionExpression
	| Identifier
	| IfStatement
	| ImportAttribute
	| ImportDeclaration
	| ImportDefaultSpecifier
	| ImportExpression
	| ImportNamespaceSpecifier
	| ImportSpecifier
	| JSXAttribute
	| JSXClosingElement
	| JSXClosingFragment
	| JSXElement
	| JSXEmptyExpression
	| JSXExpressionContainer
	| JSXFragment
	| JSXIdentifier
	| JSXMemberExpression
	| JSXNamespacedName
	| JSXOpeningElement
	| JSXOpeningFragment
	| JSXSpreadAttribute
	| JSXSpreadChild
	| JSXText
	| LabeledStatement
	| LiteralBigInt
	| LiteralBoolean
	| LiteralNull
	| LiteralNumber
	| LiteralRegExp
	| LiteralString
	| LogicalExpression
	| MemberExpression
	| MetaProperty
	| MethodDefinition
	| NewExpression
	| ObjectExpression
	| ObjectPattern
	| PrivateIdentifier
	| Program
	| Property
	| PropertyDefinition
	| RestElement
	| ReturnStatement
	| SequenceExpression
	| SpreadElement
	| StaticBlock
	| Super
	| SwitchCase
	| SwitchStatement
	| TaggedTemplateExpression
	| TemplateElement
	| TemplateLiteral
	| ThisExpression
	| ThrowStatement
	| TryStatement
	| UnaryExpression
	| UpdateExpression
	| VariableDeclaration
	| VariableDeclarator
	| WhileStatement
	| YieldExpression;
