// This file is generated by scripts/generate-ast-to-buffer.ts.
// Do not edit this file directly.

import type { AstNode } from '../rollup/ast-types';
import type { ast, SerializeAst } from '../rollup/types';
import type { AstBufferForWriting } from './getAstBuffer';
import { createAstBufferNode, createAstBufferUint8 } from './getAstBuffer';
import { error, logExpectedNodeList, logUnknownNodeType } from './logs';
import FIXED_STRING_INDICES from './serialize-ast-strings.js';

type NodeSerializer<T extends ast.AstNode> = (
	node: T,
	buffer: AstBufferForWriting
) => AstBufferForWriting;

const INITIAL_BUFFER_SIZE = 2 ** 16; // 64KB

export const serializeAst: SerializeAst | ((node: ast.AstNode) => Uint8Array) = node => {
	const initialBuffer = (
		typeof Buffer === 'undefined' ? createAstBufferUint8 : createAstBufferNode
	)(INITIAL_BUFFER_SIZE);
	const buffer = (nodeSerializers[node.type] || error(logUnknownNodeType(node.type, null, '')))(
		node as any,
		initialBuffer
	);
	return buffer.toOutput();
};

const serializeExpressionStatementNode: NodeSerializer<ast.ExpressionStatement | ast.Directive> = (
	node,
	buffer
) => {
	return 'directive' in node
		? serializeDirective(node, buffer)
		: serializeExpressionStatement(node, buffer);
};

const serializeLiteralNode: NodeSerializer<ast.Literal> = (node, buffer) => {
	switch (typeof node.value) {
		case 'object':
			if (node.value === null) {
				return serializeLiteralNull(node, buffer);
			}
			return serializeLiteralRegExp(node as ast.LiteralRegExp, buffer);
		case 'boolean':
			return serializeLiteralBoolean(node as ast.LiteralBoolean, buffer);
		case 'number':
			return serializeLiteralNumber(node as ast.LiteralNumber, buffer);
		case 'string':
			return serializeLiteralString(node as ast.LiteralString, buffer);
		case 'bigint':
			return serializeLiteralBigInt(node as ast.LiteralBigInt, buffer);
		default: {
			/* istanbul ignore next */
			throw new Error(`Unexpected node value type for Literal: ${typeof node.value}`);
		}
	}
};

type NodeSerializers = {
	[key in ast.AstNode['type']]: NodeSerializer<Extract<ast.AstNode, { type: key }>>;
};

const nodeSerializers: NodeSerializers = {
	ArrayExpression: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(4);
		buffer[nodePosition] = 2;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNodeList('elements', node, buffer, nodePosition + 3);
		return buffer;
	},
	ArrayPattern: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(4);
		buffer[nodePosition] = 3;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNodeList('elements', node, buffer, nodePosition + 3);
		return buffer;
	},
	ArrowFunctionExpression: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(7);
		buffer[nodePosition] = 4;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer[nodePosition + 3] =
			((node.async as any) << 0) | ((node.expression as any) << 1) | ((node.generator as any) << 2);
		buffer = serializeAnnotations(node.annotations, buffer, nodePosition + 4);
		buffer = serializeNodeList('params', node, buffer, nodePosition + 5);
		buffer = serializeNode('body', node, buffer, nodePosition + 6);
		return buffer;
	},
	AssignmentExpression: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(6);
		buffer[nodePosition] = 5;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer[nodePosition + 3] = FIXED_STRING_INDICES[node.operator];
		buffer = serializeNode('left', node, buffer, nodePosition + 4);
		buffer = serializeNode('right', node, buffer, nodePosition + 5);
		return buffer;
	},
	AssignmentPattern: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(5);
		buffer[nodePosition] = 6;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNode('left', node, buffer, nodePosition + 3);
		buffer = serializeNode('right', node, buffer, nodePosition + 4);
		return buffer;
	},
	AwaitExpression: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(4);
		buffer[nodePosition] = 7;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNode('argument', node, buffer, nodePosition + 3);
		return buffer;
	},
	BinaryExpression: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(6);
		buffer[nodePosition] = 8;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer[nodePosition + 3] = FIXED_STRING_INDICES[node.operator];
		buffer = serializeNode('left', node, buffer, nodePosition + 4);
		buffer = serializeNode('right', node, buffer, nodePosition + 5);
		return buffer;
	},
	BlockStatement: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(4);
		buffer[nodePosition] = 9;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNodeList('body', node, buffer, nodePosition + 3);
		return buffer;
	},
	BreakStatement: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(4);
		buffer[nodePosition] = 10;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		if (node.label != null)
			buffer = serializeNode(
				'label',
				node as AstNode & { label: AstNode },
				buffer,
				nodePosition + 3
			);
		return buffer;
	},
	CallExpression: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(7);
		buffer[nodePosition] = 11;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer[nodePosition + 3] = (node.optional as any) << 0;
		buffer = serializeAnnotations(node.annotations, buffer, nodePosition + 4);
		buffer = serializeNode('callee', node, buffer, nodePosition + 5);
		buffer = serializeNodeList('arguments', node, buffer, nodePosition + 6);
		return buffer;
	},
	CatchClause: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(5);
		buffer[nodePosition] = 12;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		if (node.param != null)
			buffer = serializeNode(
				'param',
				node as AstNode & { param: AstNode },
				buffer,
				nodePosition + 3
			);
		buffer = serializeNode('body', node, buffer, nodePosition + 4);
		return buffer;
	},
	ChainExpression: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(4);
		buffer[nodePosition] = 13;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNode('expression', node, buffer, nodePosition + 3);
		return buffer;
	},
	ClassBody: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(4);
		buffer[nodePosition] = 14;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNodeList('body', node, buffer, nodePosition + 3);
		return buffer;
	},
	ClassDeclaration: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(7);
		buffer[nodePosition] = 15;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNodeList('decorators', node, buffer, nodePosition + 3);
		if (node.id != null)
			buffer = serializeNode('id', node as AstNode & { id: AstNode }, buffer, nodePosition + 4);
		if (node.superClass != null)
			buffer = serializeNode(
				'superClass',
				node as AstNode & { superClass: AstNode },
				buffer,
				nodePosition + 5
			);
		buffer = serializeNode('body', node, buffer, nodePosition + 6);
		return buffer;
	},
	ClassExpression: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(7);
		buffer[nodePosition] = 16;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNodeList('decorators', node, buffer, nodePosition + 3);
		if (node.id != null)
			buffer = serializeNode('id', node as AstNode & { id: AstNode }, buffer, nodePosition + 4);
		if (node.superClass != null)
			buffer = serializeNode(
				'superClass',
				node as AstNode & { superClass: AstNode },
				buffer,
				nodePosition + 5
			);
		buffer = serializeNode('body', node, buffer, nodePosition + 6);
		return buffer;
	},
	ConditionalExpression: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(6);
		buffer[nodePosition] = 17;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNode('test', node, buffer, nodePosition + 3);
		buffer = serializeNode('consequent', node, buffer, nodePosition + 4);
		buffer = serializeNode('alternate', node, buffer, nodePosition + 5);
		return buffer;
	},
	ContinueStatement: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(4);
		buffer[nodePosition] = 18;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		if (node.label != null)
			buffer = serializeNode(
				'label',
				node as AstNode & { label: AstNode },
				buffer,
				nodePosition + 3
			);
		return buffer;
	},
	DebuggerStatement: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(3);
		buffer[nodePosition] = 19;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		return buffer;
	},
	Decorator: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(4);
		buffer[nodePosition] = 20;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNode('expression', node, buffer, nodePosition + 3);
		return buffer;
	},
	DoWhileStatement: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(5);
		buffer[nodePosition] = 22;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNode('body', node, buffer, nodePosition + 3);
		buffer = serializeNode('test', node, buffer, nodePosition + 4);
		return buffer;
	},
	EmptyStatement: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(3);
		buffer[nodePosition] = 23;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		return buffer;
	},
	ExportAllDeclaration: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(6);
		buffer[nodePosition] = 24;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		if (node.exported != null)
			buffer = serializeNode(
				'exported',
				node as AstNode & { exported: AstNode },
				buffer,
				nodePosition + 3
			);
		buffer = serializeNode('source', node, buffer, nodePosition + 4);
		buffer = serializeNodeList('attributes', node, buffer, nodePosition + 5);
		return buffer;
	},
	ExportDefaultDeclaration: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(4);
		buffer[nodePosition] = 25;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNode('declaration', node, buffer, nodePosition + 3);
		return buffer;
	},
	ExportNamedDeclaration: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(7);
		buffer[nodePosition] = 26;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNodeList('specifiers', node, buffer, nodePosition + 3);
		if (node.source != null)
			buffer = serializeNode(
				'source',
				node as AstNode & { source: AstNode },
				buffer,
				nodePosition + 4
			);
		buffer = serializeNodeList('attributes', node, buffer, nodePosition + 5);
		if (node.declaration != null)
			buffer = serializeNode(
				'declaration',
				node as AstNode & { declaration: AstNode },
				buffer,
				nodePosition + 6
			);
		return buffer;
	},
	ExportSpecifier: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(5);
		buffer[nodePosition] = 27;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNode('local', node, buffer, nodePosition + 3);
		if (node.exported.end != node.local.end)
			buffer = serializeNode(
				'exported',
				node as AstNode & { exported: AstNode },
				buffer,
				nodePosition + 4
			);
		return buffer;
	},
	ExpressionStatement: serializeExpressionStatementNode,
	ForInStatement: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(6);
		buffer[nodePosition] = 29;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNode('left', node, buffer, nodePosition + 3);
		buffer = serializeNode('right', node, buffer, nodePosition + 4);
		buffer = serializeNode('body', node, buffer, nodePosition + 5);
		return buffer;
	},
	ForOfStatement: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(7);
		buffer[nodePosition] = 30;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer[nodePosition + 3] = (node.await as any) << 0;
		buffer = serializeNode('left', node, buffer, nodePosition + 4);
		buffer = serializeNode('right', node, buffer, nodePosition + 5);
		buffer = serializeNode('body', node, buffer, nodePosition + 6);
		return buffer;
	},
	ForStatement: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(7);
		buffer[nodePosition] = 31;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		if (node.init != null)
			buffer = serializeNode('init', node as AstNode & { init: AstNode }, buffer, nodePosition + 3);
		if (node.test != null)
			buffer = serializeNode('test', node as AstNode & { test: AstNode }, buffer, nodePosition + 4);
		if (node.update != null)
			buffer = serializeNode(
				'update',
				node as AstNode & { update: AstNode },
				buffer,
				nodePosition + 5
			);
		buffer = serializeNode('body', node, buffer, nodePosition + 6);
		return buffer;
	},
	FunctionDeclaration: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(8);
		buffer[nodePosition] = 32;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer[nodePosition + 3] = ((node.async as any) << 0) | ((node.generator as any) << 1);
		buffer = serializeAnnotations(node.annotations, buffer, nodePosition + 4);
		if (node.id != null)
			buffer = serializeNode('id', node as AstNode & { id: AstNode }, buffer, nodePosition + 5);
		buffer = serializeNodeList('params', node, buffer, nodePosition + 6);
		buffer = serializeNode('body', node, buffer, nodePosition + 7);
		return buffer;
	},
	FunctionExpression: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(8);
		buffer[nodePosition] = 33;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer[nodePosition + 3] = ((node.async as any) << 0) | ((node.generator as any) << 1);
		buffer = serializeAnnotations(node.annotations, buffer, nodePosition + 4);
		if (node.id != null)
			buffer = serializeNode('id', node as AstNode & { id: AstNode }, buffer, nodePosition + 5);
		buffer = serializeNodeList('params', node, buffer, nodePosition + 6);
		buffer = serializeNode('body', node, buffer, nodePosition + 7);
		return buffer;
	},
	Identifier: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(4);
		buffer[nodePosition] = 34;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = buffer.addStringToBuffer(node.name, nodePosition + 3);
		return buffer;
	},
	IfStatement: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(6);
		buffer[nodePosition] = 35;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNode('test', node, buffer, nodePosition + 3);
		buffer = serializeNode('consequent', node, buffer, nodePosition + 4);
		if (node.alternate != null)
			buffer = serializeNode(
				'alternate',
				node as AstNode & { alternate: AstNode },
				buffer,
				nodePosition + 5
			);
		return buffer;
	},
	ImportAttribute: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(5);
		buffer[nodePosition] = 36;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNode('key', node, buffer, nodePosition + 3);
		buffer = serializeNode('value', node, buffer, nodePosition + 4);
		return buffer;
	},
	ImportDeclaration: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(6);
		buffer[nodePosition] = 37;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNodeList('specifiers', node, buffer, nodePosition + 3);
		buffer = serializeNode('source', node, buffer, nodePosition + 4);
		buffer = serializeNodeList('attributes', node, buffer, nodePosition + 5);
		return buffer;
	},
	ImportDefaultSpecifier: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(4);
		buffer[nodePosition] = 38;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNode('local', node, buffer, nodePosition + 3);
		return buffer;
	},
	ImportExpression: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(5);
		buffer[nodePosition] = 39;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNode('source', node, buffer, nodePosition + 3);
		if (node.options != null)
			buffer = serializeNode(
				'options',
				node as AstNode & { options: AstNode },
				buffer,
				nodePosition + 4
			);
		return buffer;
	},
	ImportNamespaceSpecifier: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(4);
		buffer[nodePosition] = 40;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNode('local', node, buffer, nodePosition + 3);
		return buffer;
	},
	ImportSpecifier: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(5);
		buffer[nodePosition] = 41;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		if (node.imported.end != node.local.end)
			buffer = serializeNode(
				'imported',
				node as AstNode & { imported: AstNode },
				buffer,
				nodePosition + 3
			);
		buffer = serializeNode('local', node, buffer, nodePosition + 4);
		return buffer;
	},
	JSXAttribute: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(5);
		buffer[nodePosition] = 42;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNode('name', node, buffer, nodePosition + 3);
		if (node.value != null)
			buffer = serializeNode(
				'value',
				node as AstNode & { value: AstNode },
				buffer,
				nodePosition + 4
			);
		return buffer;
	},
	JSXClosingElement: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(4);
		buffer[nodePosition] = 43;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNode('name', node, buffer, nodePosition + 3);
		return buffer;
	},
	JSXClosingFragment: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(3);
		buffer[nodePosition] = 44;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		return buffer;
	},
	JSXElement: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(6);
		buffer[nodePosition] = 45;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNode('openingElement', node, buffer, nodePosition + 3);
		buffer = serializeNodeList('children', node, buffer, nodePosition + 4);
		if (node.closingElement != null)
			buffer = serializeNode(
				'closingElement',
				node as AstNode & { closingElement: AstNode },
				buffer,
				nodePosition + 5
			);
		return buffer;
	},
	JSXEmptyExpression: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(3);
		buffer[nodePosition] = 46;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		return buffer;
	},
	JSXExpressionContainer: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(4);
		buffer[nodePosition] = 47;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNode('expression', node, buffer, nodePosition + 3);
		return buffer;
	},
	JSXFragment: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(6);
		buffer[nodePosition] = 48;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNode('openingFragment', node, buffer, nodePosition + 3);
		buffer = serializeNodeList('children', node, buffer, nodePosition + 4);
		buffer = serializeNode('closingFragment', node, buffer, nodePosition + 5);
		return buffer;
	},
	JSXIdentifier: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(4);
		buffer[nodePosition] = 49;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = buffer.addStringToBuffer(node.name, nodePosition + 3);
		return buffer;
	},
	JSXMemberExpression: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(5);
		buffer[nodePosition] = 50;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNode('object', node, buffer, nodePosition + 3);
		buffer = serializeNode('property', node, buffer, nodePosition + 4);
		return buffer;
	},
	JSXNamespacedName: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(5);
		buffer[nodePosition] = 51;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNode('namespace', node, buffer, nodePosition + 3);
		buffer = serializeNode('name', node, buffer, nodePosition + 4);
		return buffer;
	},
	JSXOpeningElement: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(6);
		buffer[nodePosition] = 52;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer[nodePosition + 3] = (node.selfClosing as any) << 0;
		buffer = serializeNode('name', node, buffer, nodePosition + 4);
		buffer = serializeNodeList('attributes', node, buffer, nodePosition + 5);
		return buffer;
	},
	JSXOpeningFragment: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(3);
		buffer[nodePosition] = 53;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		return buffer;
	},
	JSXSpreadAttribute: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(4);
		buffer[nodePosition] = 54;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNode('argument', node, buffer, nodePosition + 3);
		return buffer;
	},
	JSXSpreadChild: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(4);
		buffer[nodePosition] = 55;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNode('expression', node, buffer, nodePosition + 3);
		return buffer;
	},
	JSXText: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(5);
		buffer[nodePosition] = 56;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = buffer.addStringToBuffer(node.value, nodePosition + 3);
		buffer = buffer.addStringToBuffer(node.raw, nodePosition + 4);
		return buffer;
	},
	LabeledStatement: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(5);
		buffer[nodePosition] = 57;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNode('label', node, buffer, nodePosition + 3);
		buffer = serializeNode('body', node, buffer, nodePosition + 4);
		return buffer;
	},
	Literal: serializeLiteralNode,
	LogicalExpression: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(6);
		buffer[nodePosition] = 64;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer[nodePosition + 3] = FIXED_STRING_INDICES[node.operator];
		buffer = serializeNode('left', node, buffer, nodePosition + 4);
		buffer = serializeNode('right', node, buffer, nodePosition + 5);
		return buffer;
	},
	MemberExpression: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(6);
		buffer[nodePosition] = 65;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer[nodePosition + 3] = ((node.computed as any) << 0) | ((node.optional as any) << 1);
		buffer = serializeNode('object', node, buffer, nodePosition + 4);
		buffer = serializeNode('property', node, buffer, nodePosition + 5);
		return buffer;
	},
	MetaProperty: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(5);
		buffer[nodePosition] = 66;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNode('meta', node, buffer, nodePosition + 3);
		buffer = serializeNode('property', node, buffer, nodePosition + 4);
		return buffer;
	},
	MethodDefinition: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(8);
		buffer[nodePosition] = 67;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer[nodePosition + 3] = ((node.static as any) << 0) | ((node.computed as any) << 1);
		buffer = serializeNodeList('decorators', node, buffer, nodePosition + 4);
		buffer = serializeNode('key', node, buffer, nodePosition + 5);
		buffer = serializeNode('value', node, buffer, nodePosition + 6);
		buffer[nodePosition + 7] = FIXED_STRING_INDICES[node.kind];
		return buffer;
	},
	NewExpression: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(6);
		buffer[nodePosition] = 68;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeAnnotations(node.annotations, buffer, nodePosition + 3);
		buffer = serializeNode('callee', node, buffer, nodePosition + 4);
		buffer = serializeNodeList('arguments', node, buffer, nodePosition + 5);
		return buffer;
	},
	ObjectExpression: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(4);
		buffer[nodePosition] = 69;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNodeList('properties', node, buffer, nodePosition + 3);
		return buffer;
	},
	ObjectPattern: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(4);
		buffer[nodePosition] = 70;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNodeList('properties', node, buffer, nodePosition + 3);
		return buffer;
	},
	PanicError: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(4);
		buffer[nodePosition] = 0;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = buffer.addStringToBuffer(node.message, nodePosition + 3);
		return buffer;
	},
	ParseError: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(4);
		buffer[nodePosition] = 1;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = buffer.addStringToBuffer(node.message, nodePosition + 3);
		return buffer;
	},
	PrivateIdentifier: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(4);
		buffer[nodePosition] = 71;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = buffer.addStringToBuffer(node.name, nodePosition + 3);
		return buffer;
	},
	Program: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(5);
		buffer[nodePosition] = 72;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNodeList('body', node, buffer, nodePosition + 3);
		buffer = serializeAnnotations(node.invalidAnnotations, buffer, nodePosition + 4);
		return buffer;
	},
	Property: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(7);
		buffer[nodePosition] = 73;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer[nodePosition + 3] =
			((node.method as any) << 0) | ((node.shorthand as any) << 1) | ((node.computed as any) << 2);
		if (node.key.end != node.value.end)
			buffer = serializeNode('key', node as AstNode & { key: AstNode }, buffer, nodePosition + 4);
		buffer = serializeNode('value', node, buffer, nodePosition + 5);
		buffer[nodePosition + 6] = FIXED_STRING_INDICES[node.kind];
		return buffer;
	},
	PropertyDefinition: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(7);
		buffer[nodePosition] = 74;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer[nodePosition + 3] = ((node.static as any) << 0) | ((node.computed as any) << 1);
		buffer = serializeNodeList('decorators', node, buffer, nodePosition + 4);
		buffer = serializeNode('key', node, buffer, nodePosition + 5);
		if (node.value != null)
			buffer = serializeNode(
				'value',
				node as AstNode & { value: AstNode },
				buffer,
				nodePosition + 6
			);
		return buffer;
	},
	RestElement: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(4);
		buffer[nodePosition] = 75;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNode('argument', node, buffer, nodePosition + 3);
		return buffer;
	},
	ReturnStatement: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(4);
		buffer[nodePosition] = 76;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		if (node.argument != null)
			buffer = serializeNode(
				'argument',
				node as AstNode & { argument: AstNode },
				buffer,
				nodePosition + 3
			);
		return buffer;
	},
	SequenceExpression: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(4);
		buffer[nodePosition] = 77;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNodeList('expressions', node, buffer, nodePosition + 3);
		return buffer;
	},
	SpreadElement: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(4);
		buffer[nodePosition] = 78;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNode('argument', node, buffer, nodePosition + 3);
		return buffer;
	},
	StaticBlock: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(4);
		buffer[nodePosition] = 79;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNodeList('body', node, buffer, nodePosition + 3);
		return buffer;
	},
	Super: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(3);
		buffer[nodePosition] = 80;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		return buffer;
	},
	SwitchCase: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(5);
		buffer[nodePosition] = 81;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		if (node.test != null)
			buffer = serializeNode('test', node as AstNode & { test: AstNode }, buffer, nodePosition + 3);
		buffer = serializeNodeList('consequent', node, buffer, nodePosition + 4);
		return buffer;
	},
	SwitchStatement: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(5);
		buffer[nodePosition] = 82;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNode('discriminant', node, buffer, nodePosition + 3);
		buffer = serializeNodeList('cases', node, buffer, nodePosition + 4);
		return buffer;
	},
	TaggedTemplateExpression: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(5);
		buffer[nodePosition] = 83;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNode('tag', node, buffer, nodePosition + 3);
		buffer = serializeNode('quasi', node, buffer, nodePosition + 4);
		return buffer;
	},
	TemplateElement: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(6);
		buffer[nodePosition] = 84;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer[nodePosition + 3] = (node.tail as any) << 0;
		if (node.value.cooked != null) {
			buffer = buffer.addStringToBuffer(node.value.cooked, nodePosition + 4);
		}
		buffer = buffer.addStringToBuffer(node.value.raw, nodePosition + 5);
		return buffer;
	},
	TemplateLiteral: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(5);
		buffer[nodePosition] = 85;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNodeList('quasis', node, buffer, nodePosition + 3);
		buffer = serializeNodeList('expressions', node, buffer, nodePosition + 4);
		return buffer;
	},
	ThisExpression: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(3);
		buffer[nodePosition] = 86;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		return buffer;
	},
	ThrowStatement: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(4);
		buffer[nodePosition] = 87;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNode('argument', node, buffer, nodePosition + 3);
		return buffer;
	},
	TryStatement: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(6);
		buffer[nodePosition] = 88;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNode('block', node, buffer, nodePosition + 3);
		if (node.handler != null)
			buffer = serializeNode(
				'handler',
				node as AstNode & { handler: AstNode },
				buffer,
				nodePosition + 4
			);
		if (node.finalizer != null)
			buffer = serializeNode(
				'finalizer',
				node as AstNode & { finalizer: AstNode },
				buffer,
				nodePosition + 5
			);
		return buffer;
	},
	UnaryExpression: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(5);
		buffer[nodePosition] = 89;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer[nodePosition + 3] = FIXED_STRING_INDICES[node.operator];
		buffer = serializeNode('argument', node, buffer, nodePosition + 4);
		return buffer;
	},
	UpdateExpression: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(6);
		buffer[nodePosition] = 90;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer[nodePosition + 3] = (node.prefix as any) << 0;
		buffer[nodePosition + 4] = FIXED_STRING_INDICES[node.operator];
		buffer = serializeNode('argument', node, buffer, nodePosition + 5);
		return buffer;
	},
	VariableDeclaration: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(5);
		buffer[nodePosition] = 91;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer[nodePosition + 3] = FIXED_STRING_INDICES[node.kind];
		buffer = serializeNodeList('declarations', node, buffer, nodePosition + 4);
		return buffer;
	},
	VariableDeclarator: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(5);
		buffer[nodePosition] = 92;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNode('id', node, buffer, nodePosition + 3);
		if (node.init != null)
			buffer = serializeNode('init', node as AstNode & { init: AstNode }, buffer, nodePosition + 4);
		return buffer;
	},
	WhileStatement: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(5);
		buffer[nodePosition] = 93;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNode('test', node, buffer, nodePosition + 3);
		buffer = serializeNode('body', node, buffer, nodePosition + 4);
		return buffer;
	},
	YieldExpression: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer = buffer.reserve(5);
		buffer[nodePosition] = 94;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer[nodePosition + 3] = (node.delegate as any) << 0;
		if (node.argument != null)
			buffer = serializeNode(
				'argument',
				node as AstNode & { argument: AstNode },
				buffer,
				nodePosition + 4
			);
		return buffer;
	}
};

const serializeDirective: NodeSerializer<ast.Directive> = (node, buffer) => {
	const nodePosition = buffer.position;
	buffer = buffer.reserve(5);
	buffer[nodePosition] = 21;
	buffer[nodePosition + 1] = node.start;
	buffer[nodePosition + 2] = node.end;
	buffer = buffer.addStringToBuffer(node.directive, nodePosition + 3);
	buffer = serializeNode('expression', node, buffer, nodePosition + 4);
	return buffer;
};

const serializeExpressionStatement: NodeSerializer<ast.ExpressionStatement> = (node, buffer) => {
	const nodePosition = buffer.position;
	buffer = buffer.reserve(4);
	buffer[nodePosition] = 28;
	buffer[nodePosition + 1] = node.start;
	buffer[nodePosition + 2] = node.end;
	buffer = serializeNode('expression', node, buffer, nodePosition + 3);
	return buffer;
};

const serializeLiteralBigInt: NodeSerializer<ast.LiteralBigInt> = (node, buffer) => {
	const nodePosition = buffer.position;
	buffer = buffer.reserve(5);
	buffer[nodePosition] = 58;
	buffer[nodePosition + 1] = node.start;
	buffer[nodePosition + 2] = node.end;
	buffer = buffer.addStringToBuffer(node.bigint, nodePosition + 3);
	buffer = buffer.addStringToBuffer(node.raw, nodePosition + 4);
	return buffer;
};

const serializeLiteralBoolean: NodeSerializer<ast.LiteralBoolean> = (node, buffer) => {
	const nodePosition = buffer.position;
	buffer = buffer.reserve(4);
	buffer[nodePosition] = 59;
	buffer[nodePosition + 1] = node.start;
	buffer[nodePosition + 2] = node.end;
	buffer[nodePosition + 3] = (node.value as any) << 0;
	return buffer;
};

const serializeLiteralNull: NodeSerializer<ast.LiteralNull> = (node, buffer) => {
	const nodePosition = buffer.position;
	buffer = buffer.reserve(3);
	buffer[nodePosition] = 60;
	buffer[nodePosition + 1] = node.start;
	buffer[nodePosition + 2] = node.end;
	return buffer;
};

const serializeLiteralNumber: NodeSerializer<ast.LiteralNumber> = (node, buffer) => {
	const nodePosition = buffer.position;
	buffer = buffer.reserve(6);
	buffer[nodePosition] = 61;
	buffer[nodePosition + 1] = node.start;
	buffer[nodePosition + 2] = node.end;
	if (node.raw != null) {
		buffer = buffer.addStringToBuffer(node.raw, nodePosition + 3);
	}
	new DataView(buffer.buffer).setFloat64((nodePosition + 4) << 2, node.value, true);
	return buffer;
};

const serializeLiteralRegExp: NodeSerializer<ast.LiteralRegExp> = (node, buffer) => {
	const nodePosition = buffer.position;
	buffer = buffer.reserve(5);
	buffer[nodePosition] = 62;
	buffer[nodePosition + 1] = node.start;
	buffer[nodePosition + 2] = node.end;
	buffer = buffer.addStringToBuffer(node.regex.flags, nodePosition + 3);
	buffer = buffer.addStringToBuffer(node.regex.pattern, nodePosition + 4);
	return buffer;
};

const serializeLiteralString: NodeSerializer<ast.LiteralString> = (node, buffer) => {
	const nodePosition = buffer.position;
	buffer = buffer.reserve(5);
	buffer[nodePosition] = 63;
	buffer[nodePosition + 1] = node.start;
	buffer[nodePosition + 2] = node.end;
	buffer = buffer.addStringToBuffer(node.value, nodePosition + 3);
	if (node.raw != null) {
		buffer = buffer.addStringToBuffer(node.raw, nodePosition + 4);
	}
	return buffer;
};

function serializeNode<FIELD extends string>(
	field: FIELD,
	parent: AstNode & Record<FIELD, AstNode>,
	buffer: AstBufferForWriting,
	referencePosition: number
): AstBufferForWriting {
	buffer[referencePosition] = buffer.position;
	const node = parent[field];
	return (nodeSerializers[node.type] || error(logUnknownNodeType(node.type, parent.type, field)))(
		node as any,
		buffer
	);
}

function serializeNodeList<FIELD extends string>(
	field: FIELD,
	parent: AstNode & Record<FIELD, readonly (AstNode | null)[]>,
	buffer: AstBufferForWriting,
	referencePosition: number
): AstBufferForWriting {
	const nodes = parent[field];
	if (nodes == null) {
		return buffer;
	}
	const { length } = nodes;
	if (length === 0) {
		return buffer;
	}
	if (length == null) {
		return error(logExpectedNodeList(parent.type, field, parent[field]));
	}
	let insertPosition = buffer.position;
	buffer = buffer.reserve(length + 1);
	buffer[referencePosition] = insertPosition;
	buffer[insertPosition] = length;
	insertPosition++;
	for (let index = 0; index < length; index++) {
		const node = nodes[index];
		if (node != null) {
			buffer[insertPosition + index] = buffer.position;
			buffer = (
				nodeSerializers[node.type] || error(logUnknownNodeType(node.type, parent.type, field))
			)(node as any, buffer);
		}
	}
	return buffer;
}

function serializeAnnotations(
	annotations: readonly ast.Annotation[] | undefined,
	buffer: AstBufferForWriting,
	referencePosition: number
): AstBufferForWriting {
	if (annotations == null) {
		return buffer;
	}
	const { length } = annotations;
	if (length === 0) {
		return buffer;
	}
	let insertPosition = buffer.position;
	buffer = buffer.reserve(length + 1);
	buffer[referencePosition] = insertPosition;
	buffer[insertPosition] = length;
	insertPosition++;
	for (let index = 0; index < length; index++) {
		const annotation = annotations[index];
		const annotationPosition = buffer.position;
		buffer = buffer.reserve(3); // 3 for start, end, type
		buffer[insertPosition + index] = annotationPosition;
		buffer[annotationPosition] = annotation.start;
		buffer[annotationPosition + 1] = annotation.end;
		buffer[annotationPosition + 2] = FIXED_STRING_INDICES[annotation.type];
	}
	return buffer;
}
