// This file is generated by scripts/generate-ast-to-buffer.ts.
// Do not edit this file directly.

import type { ast } from '../rollup/types';
import type { NodeSerializer } from './nonCanonicalNodesToBuffer';
import { serializeExpressionStatement, serializeLiteral } from './polymorphicNodesToBuffer';

const INITIAL_BUFFER_SIZE = 2 ** 16; // 64KB

export function serializeProgram(program: ast.Program): Uint32Array {
	const initialBuffer = new Uint32Array(INITIAL_BUFFER_SIZE);
	const [buffer, position] = nodeSerializers[program.type](program, initialBuffer, 0);
	return buffer.slice(0, position);
}

type NodeSerializers = {
	[key in ast.AstNode['type']]: NodeSerializer<Extract<ast.AstNode, { type: key }>>;
};

const nodeSerializers: NodeSerializers = {
	ArrayExpression: (node, buffer, position) => {
		buffer[position] = 2;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	ArrayPattern: (node, buffer, position) => {
		buffer[position] = 3;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	ArrowFunctionExpression: (node, buffer, position) => {
		buffer[position] = 4;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	AssignmentExpression: (node, buffer, position) => {
		buffer[position] = 5;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	AssignmentPattern: (node, buffer, position) => {
		buffer[position] = 6;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	AwaitExpression: (node, buffer, position) => {
		buffer[position] = 7;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	BinaryExpression: (node, buffer, position) => {
		buffer[position] = 8;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	BlockStatement: (node, buffer, position) => {
		buffer[position] = 9;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	BreakStatement: (node, buffer, position) => {
		buffer[position] = 10;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	CallExpression: (node, buffer, position) => {
		buffer[position] = 11;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	CatchClause: (node, buffer, position) => {
		buffer[position] = 12;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	ChainExpression: (node, buffer, position) => {
		buffer[position] = 13;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	ClassBody: (node, buffer, position) => {
		buffer[position] = 14;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	ClassDeclaration: (node, buffer, position) => {
		buffer[position] = 15;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	ClassExpression: (node, buffer, position) => {
		buffer[position] = 16;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	ConditionalExpression: (node, buffer, position) => {
		buffer[position] = 17;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	ContinueStatement: (node, buffer, position) => {
		buffer[position] = 18;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	DebuggerStatement: (node, buffer, position) => {
		buffer[position] = 19;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	Decorator: (node, buffer, position) => {
		buffer[position] = 20;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	DoWhileStatement: (node, buffer, position) => {
		buffer[position] = 22;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	EmptyStatement: (node, buffer, position) => {
		buffer[position] = 23;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	ExportAllDeclaration: (node, buffer, position) => {
		buffer[position] = 24;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	ExportDefaultDeclaration: (node, buffer, position) => {
		buffer[position] = 25;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	ExportNamedDeclaration: (node, buffer, position) => {
		buffer[position] = 26;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	ExportSpecifier: (node, buffer, position) => {
		buffer[position] = 27;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	ExpressionStatement: serializeExpressionStatement,
	ForInStatement: (node, buffer, position) => {
		buffer[position] = 29;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	ForOfStatement: (node, buffer, position) => {
		buffer[position] = 30;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	ForStatement: (node, buffer, position) => {
		buffer[position] = 31;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	FunctionDeclaration: (node, buffer, position) => {
		buffer[position] = 32;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	FunctionExpression: (node, buffer, position) => {
		buffer[position] = 33;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	Identifier: (node, buffer, position) => {
		buffer[position] = 34;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	IfStatement: (node, buffer, position) => {
		buffer[position] = 35;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	ImportAttribute: (node, buffer, position) => {
		buffer[position] = 36;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	ImportDeclaration: (node, buffer, position) => {
		buffer[position] = 37;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	ImportDefaultSpecifier: (node, buffer, position) => {
		buffer[position] = 38;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	ImportExpression: (node, buffer, position) => {
		buffer[position] = 39;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	ImportNamespaceSpecifier: (node, buffer, position) => {
		buffer[position] = 40;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	ImportSpecifier: (node, buffer, position) => {
		buffer[position] = 41;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	JSXAttribute: (node, buffer, position) => {
		buffer[position] = 42;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	JSXClosingElement: (node, buffer, position) => {
		buffer[position] = 43;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	JSXClosingFragment: (node, buffer, position) => {
		buffer[position] = 44;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	JSXElement: (node, buffer, position) => {
		buffer[position] = 45;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	JSXEmptyExpression: (node, buffer, position) => {
		buffer[position] = 46;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	JSXExpressionContainer: (node, buffer, position) => {
		buffer[position] = 47;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	JSXFragment: (node, buffer, position) => {
		buffer[position] = 48;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	JSXIdentifier: (node, buffer, position) => {
		buffer[position] = 49;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	JSXMemberExpression: (node, buffer, position) => {
		buffer[position] = 50;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	JSXNamespacedName: (node, buffer, position) => {
		buffer[position] = 51;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	JSXOpeningElement: (node, buffer, position) => {
		buffer[position] = 52;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	JSXOpeningFragment: (node, buffer, position) => {
		buffer[position] = 53;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	JSXSpreadAttribute: (node, buffer, position) => {
		buffer[position] = 54;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	JSXSpreadChild: (node, buffer, position) => {
		buffer[position] = 55;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	JSXText: (node, buffer, position) => {
		buffer[position] = 56;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	LabeledStatement: (node, buffer, position) => {
		buffer[position] = 57;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	Literal: serializeLiteral,
	LogicalExpression: (node, buffer, position) => {
		buffer[position] = 64;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	MemberExpression: (node, buffer, position) => {
		buffer[position] = 65;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	MetaProperty: (node, buffer, position) => {
		buffer[position] = 66;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	MethodDefinition: (node, buffer, position) => {
		buffer[position] = 67;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	NewExpression: (node, buffer, position) => {
		buffer[position] = 68;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	ObjectExpression: (node, buffer, position) => {
		buffer[position] = 69;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	ObjectPattern: (node, buffer, position) => {
		buffer[position] = 70;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	PanicError: (node, buffer, position) => {
		buffer[position] = 0;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	ParseError: (node, buffer, position) => {
		buffer[position] = 1;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	PrivateIdentifier: (node, buffer, position) => {
		buffer[position] = 71;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	Program: (node, buffer, position) => {
		buffer[position] = 72;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	Property: (node, buffer, position) => {
		buffer[position] = 73;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	PropertyDefinition: (node, buffer, position) => {
		buffer[position] = 74;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	RestElement: (node, buffer, position) => {
		buffer[position] = 75;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	ReturnStatement: (node, buffer, position) => {
		buffer[position] = 76;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	SequenceExpression: (node, buffer, position) => {
		buffer[position] = 77;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	SpreadElement: (node, buffer, position) => {
		buffer[position] = 78;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	StaticBlock: (node, buffer, position) => {
		buffer[position] = 79;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	Super: (node, buffer, position) => {
		buffer[position] = 80;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	SwitchCase: (node, buffer, position) => {
		buffer[position] = 81;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	SwitchStatement: (node, buffer, position) => {
		buffer[position] = 82;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	TaggedTemplateExpression: (node, buffer, position) => {
		buffer[position] = 83;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	TemplateElement: (node, buffer, position) => {
		buffer[position] = 84;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	TemplateLiteral: (node, buffer, position) => {
		buffer[position] = 85;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	ThisExpression: (node, buffer, position) => {
		buffer[position] = 86;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	ThrowStatement: (node, buffer, position) => {
		buffer[position] = 87;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	TryStatement: (node, buffer, position) => {
		buffer[position] = 88;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	UnaryExpression: (node, buffer, position) => {
		buffer[position] = 89;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	UpdateExpression: (node, buffer, position) => {
		buffer[position] = 90;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	VariableDeclaration: (node, buffer, position) => {
		buffer[position] = 91;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	VariableDeclarator: (node, buffer, position) => {
		buffer[position] = 92;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	WhileStatement: (node, buffer, position) => {
		buffer[position] = 93;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	},
	YieldExpression: (node, buffer, position) => {
		buffer[position] = 94;
		buffer[position + 1] = node.start;
		buffer[position + 2] = node.end;
		return [buffer, position + 3];
	}
};
