// This file is generated by scripts/generate-ast-to-buffer.ts.
// Do not edit this file directly.

import type { AstNode } from '../rollup/ast-types';
import type { ast } from '../rollup/types';
import type { AstBufferForWriting } from './getAstBuffer';
import { createAstBuffer } from './getAstBuffer';
import FIXED_STRING_INDICES from './serialize-ast-strings.js';

type NodeSerializer<T extends ast.AstNode> = (
	node: T,
	buffer: AstBufferForWriting
) => AstBufferForWriting;

const INITIAL_BUFFER_SIZE = 2 ** 16; // 64KB

export function serializeProgram(program: ast.Program): Uint32Array {
	const initialBuffer = createAstBuffer(INITIAL_BUFFER_SIZE);
	const buffer = nodeSerializers[program.type](program, initialBuffer);
	return buffer.slice(0, buffer.position);
}

const serializeExpressionStatementNode: NodeSerializer<ast.ExpressionStatement | ast.Directive> = (
	node,
	buffer
) => {
	return 'directive' in node
		? serializeDirective(node, buffer)
		: serializeExpressionStatement(node, buffer);
};

const serializeLiteralNode: NodeSerializer<ast.Literal> = (node, buffer) => {
	switch (typeof node.value) {
		case 'object':
			if (node.value === null) {
				return serializeLiteralNull(node, buffer);
			}
			return serializeLiteralRegExp(node as ast.LiteralRegExp, buffer);
		case 'boolean':
			return serializeLiteralBoolean(node as ast.LiteralBoolean, buffer);
		case 'number':
			return serializeLiteralNumber(node as ast.LiteralNumber, buffer);
		case 'string':
			return serializeLiteralString(node as ast.LiteralString, buffer);
		case 'bigint':
			return serializeLiteralBigInt(node as ast.LiteralBigInt, buffer);
		default: {
			/* istanbul ignore next */
			throw new Error(`Unexpected node value type for Literal: ${typeof node.value}`);
		}
	}
};

type NodeSerializers = {
	[key in ast.AstNode['type']]: NodeSerializer<Extract<ast.AstNode, { type: key }>>;
};

const nodeSerializers: NodeSerializers = {
	ArrayExpression: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 4;
		buffer[nodePosition] = 2;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNodeList(node.elements, buffer, nodePosition + 3);
		return buffer;
	},
	ArrayPattern: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 4;
		buffer[nodePosition] = 3;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNodeList(node.elements, buffer, nodePosition + 3);
		return buffer;
	},
	ArrowFunctionExpression: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 7;
		buffer[nodePosition] = 4;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		// TODO annotations: Annotations
		buffer = serializeNodeList(node.params, buffer, nodePosition + 5);
		buffer = serializeNode(node.body, buffer, nodePosition + 6);
		return buffer;
	},
	AssignmentExpression: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 6;
		buffer[nodePosition] = 5;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer[nodePosition + 3] = FIXED_STRING_INDICES[node.operator];
		buffer = serializeNode(node.left, buffer, nodePosition + 4);
		buffer = serializeNode(node.right, buffer, nodePosition + 5);
		return buffer;
	},
	AssignmentPattern: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 5;
		buffer[nodePosition] = 6;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNode(node.left, buffer, nodePosition + 3);
		buffer = serializeNode(node.right, buffer, nodePosition + 4);
		return buffer;
	},
	AwaitExpression: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 4;
		buffer[nodePosition] = 7;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNode(node.argument, buffer, nodePosition + 3);
		return buffer;
	},
	BinaryExpression: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 6;
		buffer[nodePosition] = 8;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer[nodePosition + 3] = FIXED_STRING_INDICES[node.operator];
		buffer = serializeNode(node.left, buffer, nodePosition + 4);
		buffer = serializeNode(node.right, buffer, nodePosition + 5);
		return buffer;
	},
	BlockStatement: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 4;
		buffer[nodePosition] = 9;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNodeList(node.body, buffer, nodePosition + 3);
		return buffer;
	},
	BreakStatement: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 4;
		buffer[nodePosition] = 10;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		if (node.label != null) buffer = serializeNode(node.label, buffer, nodePosition + 3);
		return buffer;
	},
	CallExpression: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 7;
		buffer[nodePosition] = 11;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		// TODO annotations: Annotations
		buffer = serializeNode(node.callee, buffer, nodePosition + 5);
		buffer = serializeNodeList(node.arguments, buffer, nodePosition + 6);
		return buffer;
	},
	CatchClause: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 5;
		buffer[nodePosition] = 12;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		if (node.param != null) buffer = serializeNode(node.param, buffer, nodePosition + 3);
		buffer = serializeNode(node.body, buffer, nodePosition + 4);
		return buffer;
	},
	ChainExpression: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 4;
		buffer[nodePosition] = 13;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNode(node.expression, buffer, nodePosition + 3);
		return buffer;
	},
	ClassBody: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 4;
		buffer[nodePosition] = 14;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNodeList(node.body, buffer, nodePosition + 3);
		return buffer;
	},
	ClassDeclaration: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 7;
		buffer[nodePosition] = 15;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNodeList(node.decorators, buffer, nodePosition + 3);
		if (node.id != null) buffer = serializeNode(node.id, buffer, nodePosition + 4);
		if (node.superClass != null) buffer = serializeNode(node.superClass, buffer, nodePosition + 5);
		buffer = serializeNode(node.body, buffer, nodePosition + 6);
		return buffer;
	},
	ClassExpression: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 7;
		buffer[nodePosition] = 16;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNodeList(node.decorators, buffer, nodePosition + 3);
		if (node.id != null) buffer = serializeNode(node.id, buffer, nodePosition + 4);
		if (node.superClass != null) buffer = serializeNode(node.superClass, buffer, nodePosition + 5);
		buffer = serializeNode(node.body, buffer, nodePosition + 6);
		return buffer;
	},
	ConditionalExpression: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 6;
		buffer[nodePosition] = 17;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNode(node.test, buffer, nodePosition + 3);
		buffer = serializeNode(node.consequent, buffer, nodePosition + 4);
		buffer = serializeNode(node.alternate, buffer, nodePosition + 5);
		return buffer;
	},
	ContinueStatement: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 4;
		buffer[nodePosition] = 18;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		if (node.label != null) buffer = serializeNode(node.label, buffer, nodePosition + 3);
		return buffer;
	},
	DebuggerStatement: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 3;
		buffer[nodePosition] = 19;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		return buffer;
	},
	Decorator: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 4;
		buffer[nodePosition] = 20;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNode(node.expression, buffer, nodePosition + 3);
		return buffer;
	},
	DoWhileStatement: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 5;
		buffer[nodePosition] = 22;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNode(node.body, buffer, nodePosition + 3);
		buffer = serializeNode(node.test, buffer, nodePosition + 4);
		return buffer;
	},
	EmptyStatement: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 3;
		buffer[nodePosition] = 23;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		return buffer;
	},
	ExportAllDeclaration: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 6;
		buffer[nodePosition] = 24;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		if (node.exported != null) buffer = serializeNode(node.exported, buffer, nodePosition + 3);
		buffer = serializeNode(node.source, buffer, nodePosition + 4);
		buffer = serializeNodeList(node.attributes, buffer, nodePosition + 5);
		return buffer;
	},
	ExportDefaultDeclaration: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 4;
		buffer[nodePosition] = 25;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNode(node.declaration, buffer, nodePosition + 3);
		return buffer;
	},
	ExportNamedDeclaration: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 7;
		buffer[nodePosition] = 26;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNodeList(node.specifiers, buffer, nodePosition + 3);
		if (node.source != null) buffer = serializeNode(node.source, buffer, nodePosition + 4);
		buffer = serializeNodeList(node.attributes, buffer, nodePosition + 5);
		if (node.declaration != null)
			buffer = serializeNode(node.declaration, buffer, nodePosition + 6);
		return buffer;
	},
	ExportSpecifier: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 5;
		buffer[nodePosition] = 27;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNode(node.local, buffer, nodePosition + 3);
		if (node.exported != null) buffer = serializeNode(node.exported, buffer, nodePosition + 4);
		return buffer;
	},
	ExpressionStatement: serializeExpressionStatementNode,
	ForInStatement: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 6;
		buffer[nodePosition] = 29;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNode(node.left, buffer, nodePosition + 3);
		buffer = serializeNode(node.right, buffer, nodePosition + 4);
		buffer = serializeNode(node.body, buffer, nodePosition + 5);
		return buffer;
	},
	ForOfStatement: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 7;
		buffer[nodePosition] = 30;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNode(node.left, buffer, nodePosition + 4);
		buffer = serializeNode(node.right, buffer, nodePosition + 5);
		buffer = serializeNode(node.body, buffer, nodePosition + 6);
		return buffer;
	},
	ForStatement: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 7;
		buffer[nodePosition] = 31;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		if (node.init != null) buffer = serializeNode(node.init, buffer, nodePosition + 3);
		if (node.test != null) buffer = serializeNode(node.test, buffer, nodePosition + 4);
		if (node.update != null) buffer = serializeNode(node.update, buffer, nodePosition + 5);
		buffer = serializeNode(node.body, buffer, nodePosition + 6);
		return buffer;
	},
	FunctionDeclaration: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 8;
		buffer[nodePosition] = 32;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		// TODO annotations: Annotations
		if (node.id != null) buffer = serializeNode(node.id, buffer, nodePosition + 5);
		buffer = serializeNodeList(node.params, buffer, nodePosition + 6);
		buffer = serializeNode(node.body, buffer, nodePosition + 7);
		return buffer;
	},
	FunctionExpression: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 8;
		buffer[nodePosition] = 33;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		// TODO annotations: Annotations
		if (node.id != null) buffer = serializeNode(node.id, buffer, nodePosition + 5);
		buffer = serializeNodeList(node.params, buffer, nodePosition + 6);
		buffer = serializeNode(node.body, buffer, nodePosition + 7);
		return buffer;
	},
	Identifier: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 4;
		buffer[nodePosition] = 34;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer.addStringToBuffer(node.name, nodePosition + 3);
		return buffer;
	},
	IfStatement: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 6;
		buffer[nodePosition] = 35;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNode(node.test, buffer, nodePosition + 3);
		buffer = serializeNode(node.consequent, buffer, nodePosition + 4);
		if (node.alternate != null) buffer = serializeNode(node.alternate, buffer, nodePosition + 5);
		return buffer;
	},
	ImportAttribute: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 5;
		buffer[nodePosition] = 36;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNode(node.key, buffer, nodePosition + 3);
		buffer = serializeNode(node.value, buffer, nodePosition + 4);
		return buffer;
	},
	ImportDeclaration: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 6;
		buffer[nodePosition] = 37;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNodeList(node.specifiers, buffer, nodePosition + 3);
		buffer = serializeNode(node.source, buffer, nodePosition + 4);
		buffer = serializeNodeList(node.attributes, buffer, nodePosition + 5);
		return buffer;
	},
	ImportDefaultSpecifier: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 4;
		buffer[nodePosition] = 38;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNode(node.local, buffer, nodePosition + 3);
		return buffer;
	},
	ImportExpression: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 5;
		buffer[nodePosition] = 39;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNode(node.source, buffer, nodePosition + 3);
		if (node.options != null) buffer = serializeNode(node.options, buffer, nodePosition + 4);
		return buffer;
	},
	ImportNamespaceSpecifier: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 4;
		buffer[nodePosition] = 40;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNode(node.local, buffer, nodePosition + 3);
		return buffer;
	},
	ImportSpecifier: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 5;
		buffer[nodePosition] = 41;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		if (node.imported != null) buffer = serializeNode(node.imported, buffer, nodePosition + 3);
		buffer = serializeNode(node.local, buffer, nodePosition + 4);
		return buffer;
	},
	JSXAttribute: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 5;
		buffer[nodePosition] = 42;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNode(node.name, buffer, nodePosition + 3);
		if (node.value != null) buffer = serializeNode(node.value, buffer, nodePosition + 4);
		return buffer;
	},
	JSXClosingElement: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 4;
		buffer[nodePosition] = 43;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNode(node.name, buffer, nodePosition + 3);
		return buffer;
	},
	JSXClosingFragment: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 3;
		buffer[nodePosition] = 44;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		return buffer;
	},
	JSXElement: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 6;
		buffer[nodePosition] = 45;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNode(node.openingElement, buffer, nodePosition + 3);
		buffer = serializeNodeList(node.children, buffer, nodePosition + 4);
		if (node.closingElement != null)
			buffer = serializeNode(node.closingElement, buffer, nodePosition + 5);
		return buffer;
	},
	JSXEmptyExpression: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 3;
		buffer[nodePosition] = 46;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		return buffer;
	},
	JSXExpressionContainer: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 4;
		buffer[nodePosition] = 47;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNode(node.expression, buffer, nodePosition + 3);
		return buffer;
	},
	JSXFragment: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 6;
		buffer[nodePosition] = 48;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNode(node.openingFragment, buffer, nodePosition + 3);
		buffer = serializeNodeList(node.children, buffer, nodePosition + 4);
		buffer = serializeNode(node.closingFragment, buffer, nodePosition + 5);
		return buffer;
	},
	JSXIdentifier: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 4;
		buffer[nodePosition] = 49;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer.addStringToBuffer(node.name, nodePosition + 3);
		return buffer;
	},
	JSXMemberExpression: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 5;
		buffer[nodePosition] = 50;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNode(node.object, buffer, nodePosition + 3);
		buffer = serializeNode(node.property, buffer, nodePosition + 4);
		return buffer;
	},
	JSXNamespacedName: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 5;
		buffer[nodePosition] = 51;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNode(node.namespace, buffer, nodePosition + 3);
		buffer = serializeNode(node.name, buffer, nodePosition + 4);
		return buffer;
	},
	JSXOpeningElement: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 6;
		buffer[nodePosition] = 52;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNode(node.name, buffer, nodePosition + 4);
		buffer = serializeNodeList(node.attributes, buffer, nodePosition + 5);
		return buffer;
	},
	JSXOpeningFragment: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 3;
		buffer[nodePosition] = 53;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		return buffer;
	},
	JSXSpreadAttribute: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 4;
		buffer[nodePosition] = 54;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNode(node.argument, buffer, nodePosition + 3);
		return buffer;
	},
	JSXSpreadChild: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 4;
		buffer[nodePosition] = 55;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNode(node.expression, buffer, nodePosition + 3);
		return buffer;
	},
	JSXText: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 5;
		buffer[nodePosition] = 56;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer.addStringToBuffer(node.value, nodePosition + 3);
		buffer.addStringToBuffer(node.raw, nodePosition + 4);
		return buffer;
	},
	LabeledStatement: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 5;
		buffer[nodePosition] = 57;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNode(node.label, buffer, nodePosition + 3);
		buffer = serializeNode(node.body, buffer, nodePosition + 4);
		return buffer;
	},
	Literal: serializeLiteralNode,
	LogicalExpression: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 6;
		buffer[nodePosition] = 64;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer[nodePosition + 3] = FIXED_STRING_INDICES[node.operator];
		buffer = serializeNode(node.left, buffer, nodePosition + 4);
		buffer = serializeNode(node.right, buffer, nodePosition + 5);
		return buffer;
	},
	MemberExpression: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 6;
		buffer[nodePosition] = 65;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNode(node.object, buffer, nodePosition + 4);
		buffer = serializeNode(node.property, buffer, nodePosition + 5);
		return buffer;
	},
	MetaProperty: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 5;
		buffer[nodePosition] = 66;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNode(node.meta, buffer, nodePosition + 3);
		buffer = serializeNode(node.property, buffer, nodePosition + 4);
		return buffer;
	},
	MethodDefinition: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 8;
		buffer[nodePosition] = 67;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNodeList(node.decorators, buffer, nodePosition + 4);
		buffer = serializeNode(node.key, buffer, nodePosition + 5);
		buffer = serializeNode(node.value, buffer, nodePosition + 6);
		buffer[nodePosition + 7] = FIXED_STRING_INDICES[node.kind];
		return buffer;
	},
	NewExpression: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 6;
		buffer[nodePosition] = 68;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		// TODO annotations: Annotations
		buffer = serializeNode(node.callee, buffer, nodePosition + 4);
		buffer = serializeNodeList(node.arguments, buffer, nodePosition + 5);
		return buffer;
	},
	ObjectExpression: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 4;
		buffer[nodePosition] = 69;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNodeList(node.properties, buffer, nodePosition + 3);
		return buffer;
	},
	ObjectPattern: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 4;
		buffer[nodePosition] = 70;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNodeList(node.properties, buffer, nodePosition + 3);
		return buffer;
	},
	PanicError: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 4;
		buffer[nodePosition] = 0;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer.addStringToBuffer(node.message, nodePosition + 3);
		return buffer;
	},
	ParseError: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 4;
		buffer[nodePosition] = 1;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer.addStringToBuffer(node.message, nodePosition + 3);
		return buffer;
	},
	PrivateIdentifier: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 4;
		buffer[nodePosition] = 71;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer.addStringToBuffer(node.name, nodePosition + 3);
		return buffer;
	},
	Program: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 5;
		buffer[nodePosition] = 72;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNodeList(node.body, buffer, nodePosition + 3);
		// TODO invalidAnnotations: Annotations
		return buffer;
	},
	Property: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 7;
		buffer[nodePosition] = 73;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		if (node.key != null) buffer = serializeNode(node.key, buffer, nodePosition + 4);
		buffer = serializeNode(node.value, buffer, nodePosition + 5);
		buffer[nodePosition + 6] = FIXED_STRING_INDICES[node.kind];
		return buffer;
	},
	PropertyDefinition: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 7;
		buffer[nodePosition] = 74;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNodeList(node.decorators, buffer, nodePosition + 4);
		buffer = serializeNode(node.key, buffer, nodePosition + 5);
		if (node.value != null) buffer = serializeNode(node.value, buffer, nodePosition + 6);
		return buffer;
	},
	RestElement: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 4;
		buffer[nodePosition] = 75;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNode(node.argument, buffer, nodePosition + 3);
		return buffer;
	},
	ReturnStatement: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 4;
		buffer[nodePosition] = 76;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		if (node.argument != null) buffer = serializeNode(node.argument, buffer, nodePosition + 3);
		return buffer;
	},
	SequenceExpression: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 4;
		buffer[nodePosition] = 77;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNodeList(node.expressions, buffer, nodePosition + 3);
		return buffer;
	},
	SpreadElement: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 4;
		buffer[nodePosition] = 78;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNode(node.argument, buffer, nodePosition + 3);
		return buffer;
	},
	StaticBlock: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 4;
		buffer[nodePosition] = 79;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNodeList(node.body, buffer, nodePosition + 3);
		return buffer;
	},
	Super: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 3;
		buffer[nodePosition] = 80;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		return buffer;
	},
	SwitchCase: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 5;
		buffer[nodePosition] = 81;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		if (node.test != null) buffer = serializeNode(node.test, buffer, nodePosition + 3);
		buffer = serializeNodeList(node.consequent, buffer, nodePosition + 4);
		return buffer;
	},
	SwitchStatement: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 5;
		buffer[nodePosition] = 82;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNode(node.discriminant, buffer, nodePosition + 3);
		buffer = serializeNodeList(node.cases, buffer, nodePosition + 4);
		return buffer;
	},
	TaggedTemplateExpression: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 5;
		buffer[nodePosition] = 83;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNode(node.tag, buffer, nodePosition + 3);
		buffer = serializeNode(node.quasi, buffer, nodePosition + 4);
		return buffer;
	},
	TemplateElement: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 6;
		buffer[nodePosition] = 84;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		if (node.value.cooked != null) {
			buffer.addStringToBuffer(node.value.cooked, nodePosition + 4);
		}
		buffer.addStringToBuffer(node.value.raw, nodePosition + 5);
		return buffer;
	},
	TemplateLiteral: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 5;
		buffer[nodePosition] = 85;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNodeList(node.quasis, buffer, nodePosition + 3);
		buffer = serializeNodeList(node.expressions, buffer, nodePosition + 4);
		return buffer;
	},
	ThisExpression: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 3;
		buffer[nodePosition] = 86;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		return buffer;
	},
	ThrowStatement: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 4;
		buffer[nodePosition] = 87;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNode(node.argument, buffer, nodePosition + 3);
		return buffer;
	},
	TryStatement: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 6;
		buffer[nodePosition] = 88;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNode(node.block, buffer, nodePosition + 3);
		if (node.handler != null) buffer = serializeNode(node.handler, buffer, nodePosition + 4);
		if (node.finalizer != null) buffer = serializeNode(node.finalizer, buffer, nodePosition + 5);
		return buffer;
	},
	UnaryExpression: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 5;
		buffer[nodePosition] = 89;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer[nodePosition + 3] = FIXED_STRING_INDICES[node.operator];
		buffer = serializeNode(node.argument, buffer, nodePosition + 4);
		return buffer;
	},
	UpdateExpression: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 6;
		buffer[nodePosition] = 90;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer[nodePosition + 4] = FIXED_STRING_INDICES[node.operator];
		buffer = serializeNode(node.argument, buffer, nodePosition + 5);
		return buffer;
	},
	VariableDeclaration: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 5;
		buffer[nodePosition] = 91;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer[nodePosition + 3] = FIXED_STRING_INDICES[node.kind];
		buffer = serializeNodeList(node.declarations, buffer, nodePosition + 4);
		return buffer;
	},
	VariableDeclarator: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 5;
		buffer[nodePosition] = 92;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNode(node.id, buffer, nodePosition + 3);
		if (node.init != null) buffer = serializeNode(node.init, buffer, nodePosition + 4);
		return buffer;
	},
	WhileStatement: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 5;
		buffer[nodePosition] = 93;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		buffer = serializeNode(node.test, buffer, nodePosition + 3);
		buffer = serializeNode(node.body, buffer, nodePosition + 4);
		return buffer;
	},
	YieldExpression: (node, buffer) => {
		const nodePosition = buffer.position;
		buffer.position = nodePosition + 5;
		buffer[nodePosition] = 94;
		buffer[nodePosition + 1] = node.start;
		buffer[nodePosition + 2] = node.end;
		if (node.argument != null) buffer = serializeNode(node.argument, buffer, nodePosition + 4);
		return buffer;
	}
};

const serializeDirective: NodeSerializer<ast.Directive> = (node, buffer) => {
	const nodePosition = buffer.position;
	buffer.position = nodePosition + 5;
	buffer[nodePosition] = 21;
	buffer[nodePosition + 1] = node.start;
	buffer[nodePosition + 2] = node.end;
	buffer.addStringToBuffer(node.directive, nodePosition + 3);
	buffer = serializeNode(node.expression, buffer, nodePosition + 4);
	return buffer;
};

const serializeExpressionStatement: NodeSerializer<ast.ExpressionStatement> = (node, buffer) => {
	const nodePosition = buffer.position;
	buffer.position = nodePosition + 4;
	buffer[nodePosition] = 28;
	buffer[nodePosition + 1] = node.start;
	buffer[nodePosition + 2] = node.end;
	buffer = serializeNode(node.expression, buffer, nodePosition + 3);
	return buffer;
};

const serializeLiteralBigInt: NodeSerializer<ast.LiteralBigInt> = (node, buffer) => {
	const nodePosition = buffer.position;
	buffer.position = nodePosition + 5;
	buffer[nodePosition] = 58;
	buffer[nodePosition + 1] = node.start;
	buffer[nodePosition + 2] = node.end;
	buffer.addStringToBuffer(node.bigint, nodePosition + 3);
	buffer.addStringToBuffer(node.raw, nodePosition + 4);
	return buffer;
};

const serializeLiteralBoolean: NodeSerializer<ast.LiteralBoolean> = (node, buffer) => {
	const nodePosition = buffer.position;
	buffer.position = nodePosition + 4;
	buffer[nodePosition] = 59;
	buffer[nodePosition + 1] = node.start;
	buffer[nodePosition + 2] = node.end;
	return buffer;
};

const serializeLiteralNull: NodeSerializer<ast.LiteralNull> = (node, buffer) => {
	const nodePosition = buffer.position;
	buffer.position = nodePosition + 3;
	buffer[nodePosition] = 60;
	buffer[nodePosition + 1] = node.start;
	buffer[nodePosition + 2] = node.end;
	return buffer;
};

const serializeLiteralNumber: NodeSerializer<ast.LiteralNumber> = (node, buffer) => {
	const nodePosition = buffer.position;
	buffer.position = nodePosition + 6;
	buffer[nodePosition] = 61;
	buffer[nodePosition + 1] = node.start;
	buffer[nodePosition + 2] = node.end;
	if (node.raw != null) {
		buffer.addStringToBuffer(node.raw, nodePosition + 3);
	}
	new DataView(buffer.buffer).setFloat64((nodePosition + 4) << 2, node.value);
	return buffer;
};

const serializeLiteralRegExp: NodeSerializer<ast.LiteralRegExp> = (node, buffer) => {
	const nodePosition = buffer.position;
	buffer.position = nodePosition + 5;
	buffer[nodePosition] = 62;
	buffer[nodePosition + 1] = node.start;
	buffer[nodePosition + 2] = node.end;
	buffer.addStringToBuffer(node.regex.flags, nodePosition + 3);
	buffer.addStringToBuffer(node.regex.pattern, nodePosition + 4);
	return buffer;
};

const serializeLiteralString: NodeSerializer<ast.LiteralString> = (node, buffer) => {
	const nodePosition = buffer.position;
	buffer.position = nodePosition + 5;
	buffer[nodePosition] = 63;
	buffer[nodePosition + 1] = node.start;
	buffer[nodePosition + 2] = node.end;
	buffer.addStringToBuffer(node.value, nodePosition + 3);
	if (node.raw != null) {
		buffer.addStringToBuffer(node.raw, nodePosition + 4);
	}
	return buffer;
};

function serializeNode(
	node: AstNode,
	buffer: AstBufferForWriting,
	referencePosition: number
): AstBufferForWriting {
	buffer[referencePosition] = buffer.position;
	buffer.position++;
	return nodeSerializers[node.type](node as any, buffer);
}

function serializeNodeList(
	nodes: readonly (AstNode | null)[],
	buffer: AstBufferForWriting,
	referencePosition: number
): AstBufferForWriting {
	const { length } = nodes;
	if (length === 0) {
		buffer[referencePosition] = 0;
		return buffer;
	}
	let insertPosition = buffer.position;
	buffer[referencePosition] = insertPosition;
	buffer[insertPosition] = length;
	insertPosition++;
	buffer.position = insertPosition + length;
	for (let index = 0; index < length; index++) {
		const node = nodes[index];
		if (node != null) {
			buffer[insertPosition + index] = buffer.position;
			buffer = nodeSerializers[node.type](node as any, buffer);
		}
	}
	return buffer;
}
