// This file is generated by scripts/generate-buffer-to-ast.ts.
// Do not edit this file directly.

import { PanicError, ParseError } from '../ast/nodes/NodeType';
import type { ast } from '../rollup/types';
import { convertAnnotations } from './astConverterHelpers';
import { EMPTY_ARRAY } from './blank';
import FIXED_STRINGS from './convert-ast-strings';
import type { AstBuffer } from './getAstBuffer';
import { error, getRollupError, logParseError } from './logs';

export function deserializeLazyAst(position: number, buffer: AstBuffer): ast.AstNode {
	const node = convertNode(position, buffer);
	switch (node.type) {
		case PanicError: {
			return error(getRollupError(logParseError(node.message)));
		}
		case ParseError: {
			return error(getRollupError(logParseError(node.message, node.start)));
		}
		default: {
			return node;
		}
	}
}

/* eslint-disable sort-keys */
const nodeConverters: ((position: number, buffer: AstBuffer) => any)[] = [
	function panicError(position, buffer): ast.PanicError {
		const node: ast.PanicError = {
			type: 'PanicError',
			start: buffer[position],
			end: buffer[position + 1],
			get message() {
				const result = buffer.convertString(buffer[position + 2]);
				Object.defineProperty(node, 'message', { value: result });
				return result;
			}
		};
		return node;
	},
	function parseError(position, buffer): ast.ParseError {
		const node: ast.ParseError = {
			type: 'ParseError',
			start: buffer[position],
			end: buffer[position + 1],
			get message() {
				const result = buffer.convertString(buffer[position + 2]);
				Object.defineProperty(node, 'message', { value: result });
				return result;
			}
		};
		return node;
	},
	function arrayExpression(position, buffer): ast.ArrayExpression {
		const node: ast.ArrayExpression = {
			type: 'ArrayExpression',
			start: buffer[position],
			end: buffer[position + 1],
			get elements() {
				const result = convertNodeList(buffer[position + 2], buffer);
				Object.defineProperty(node, 'elements', { value: result });
				return result;
			}
		};
		return node;
	},
	function arrayPattern(position, buffer): ast.ArrayPattern {
		const node: ast.ArrayPattern = {
			type: 'ArrayPattern',
			start: buffer[position],
			end: buffer[position + 1],
			get elements() {
				const result = convertNodeList(buffer[position + 2], buffer);
				Object.defineProperty(node, 'elements', { value: result });
				return result;
			}
		};
		return node;
	},
	function arrowFunctionExpression(position, buffer): ast.ArrowFunctionExpression {
		const flags = buffer[position + 2];
		const annotations = convertAnnotations(buffer[position + 3], buffer);
		const node: ast.ArrowFunctionExpression = {
			type: 'ArrowFunctionExpression',
			start: buffer[position],
			end: buffer[position + 1],
			async: (flags & 1) === 1,
			expression: (flags & 2) === 2,
			generator: (flags & 4) === 4,
			...(annotations.length > 0 ? { annotations } : {}),
			get params() {
				const result = convertNodeList(buffer[position + 4], buffer);
				Object.defineProperty(node, 'params', { value: result });
				return result;
			},
			get body() {
				const result = convertNode(buffer[position + 5], buffer);
				Object.defineProperty(node, 'body', { value: result });
				return result;
			},
			id: null
		};
		return node;
	},
	function assignmentExpression(position, buffer): ast.AssignmentExpression {
		const node: ast.AssignmentExpression = {
			type: 'AssignmentExpression',
			start: buffer[position],
			end: buffer[position + 1],
			get operator() {
				const result = FIXED_STRINGS[buffer[position + 2]] as ast.AssignmentExpression['operator'];
				Object.defineProperty(node, 'operator', { value: result });
				return result;
			},
			get left() {
				const result = convertNode(buffer[position + 3], buffer);
				Object.defineProperty(node, 'left', { value: result });
				return result;
			},
			get right() {
				const result = convertNode(buffer[position + 4], buffer);
				Object.defineProperty(node, 'right', { value: result });
				return result;
			}
		};
		return node;
	},
	function assignmentPattern(position, buffer): ast.AssignmentPattern {
		const node: ast.AssignmentPattern = {
			type: 'AssignmentPattern',
			start: buffer[position],
			end: buffer[position + 1],
			get left() {
				const result = convertNode(buffer[position + 2], buffer);
				Object.defineProperty(node, 'left', { value: result });
				return result;
			},
			get right() {
				const result = convertNode(buffer[position + 3], buffer);
				Object.defineProperty(node, 'right', { value: result });
				return result;
			}
		};
		return node;
	},
	function awaitExpression(position, buffer): ast.AwaitExpression {
		const node: ast.AwaitExpression = {
			type: 'AwaitExpression',
			start: buffer[position],
			end: buffer[position + 1],
			get argument() {
				const result = convertNode(buffer[position + 2], buffer);
				Object.defineProperty(node, 'argument', { value: result });
				return result;
			}
		};
		return node;
	},
	function binaryExpression(position, buffer): ast.BinaryExpression {
		const node: ast.BinaryExpression = {
			type: 'BinaryExpression',
			start: buffer[position],
			end: buffer[position + 1],
			get operator() {
				const result = FIXED_STRINGS[buffer[position + 2]] as ast.BinaryExpression['operator'];
				Object.defineProperty(node, 'operator', { value: result });
				return result;
			},
			get left() {
				const result = convertNode(buffer[position + 3], buffer);
				Object.defineProperty(node, 'left', { value: result });
				return result;
			},
			get right() {
				const result = convertNode(buffer[position + 4], buffer);
				Object.defineProperty(node, 'right', { value: result });
				return result;
			}
		};
		return node;
	},
	function blockStatement(position, buffer): ast.BlockStatement {
		const node: ast.BlockStatement = {
			type: 'BlockStatement',
			start: buffer[position],
			end: buffer[position + 1],
			get body() {
				const result = convertNodeList(buffer[position + 2], buffer);
				Object.defineProperty(node, 'body', { value: result });
				return result;
			}
		};
		return node;
	},
	function breakStatement(position, buffer): ast.BreakStatement {
		const labelPosition = buffer[position + 2];
		const node: ast.BreakStatement = {
			type: 'BreakStatement',
			start: buffer[position],
			end: buffer[position + 1],
			get label() {
				const result = labelPosition === 0 ? null : convertNode(labelPosition, buffer);
				Object.defineProperty(node, 'label', { value: result });
				return result;
			}
		};
		return node;
	},
	function callExpression(position, buffer): ast.CallExpression {
		const flags = buffer[position + 2];
		const annotations = convertAnnotations(buffer[position + 3], buffer);
		const node: ast.CallExpression = {
			type: 'CallExpression',
			start: buffer[position],
			end: buffer[position + 1],
			optional: (flags & 1) === 1,
			...(annotations.length > 0 ? { annotations } : {}),
			get callee() {
				const result = convertNode(buffer[position + 4], buffer);
				Object.defineProperty(node, 'callee', { value: result });
				return result;
			},
			get arguments() {
				const result = convertNodeList(buffer[position + 5], buffer);
				Object.defineProperty(node, 'arguments', { value: result });
				return result;
			}
		};
		return node;
	},
	function catchClause(position, buffer): ast.CatchClause {
		const parameterPosition = buffer[position + 2];
		const node: ast.CatchClause = {
			type: 'CatchClause',
			start: buffer[position],
			end: buffer[position + 1],
			get param() {
				const result = parameterPosition === 0 ? null : convertNode(parameterPosition, buffer);
				Object.defineProperty(node, 'param', { value: result });
				return result;
			},
			get body() {
				const result = convertNode(buffer[position + 3], buffer);
				Object.defineProperty(node, 'body', { value: result });
				return result;
			}
		};
		return node;
	},
	function chainExpression(position, buffer): ast.ChainExpression {
		const node: ast.ChainExpression = {
			type: 'ChainExpression',
			start: buffer[position],
			end: buffer[position + 1],
			get expression() {
				const result = convertNode(buffer[position + 2], buffer);
				Object.defineProperty(node, 'expression', { value: result });
				return result;
			}
		};
		return node;
	},
	function classBody(position, buffer): ast.ClassBody {
		const node: ast.ClassBody = {
			type: 'ClassBody',
			start: buffer[position],
			end: buffer[position + 1],
			get body() {
				const result = convertNodeList(buffer[position + 2], buffer);
				Object.defineProperty(node, 'body', { value: result });
				return result;
			}
		};
		return node;
	},
	function classDeclaration(position, buffer): ast.ClassDeclaration {
		const idPosition = buffer[position + 3];
		const superClassPosition = buffer[position + 4];
		const node: ast.ClassDeclaration = {
			type: 'ClassDeclaration',
			start: buffer[position],
			end: buffer[position + 1],
			get decorators() {
				const result = convertNodeList(buffer[position + 2], buffer);
				Object.defineProperty(node, 'decorators', { value: result });
				return result;
			},
			get id() {
				const result = idPosition === 0 ? null : convertNode(idPosition, buffer);
				Object.defineProperty(node, 'id', { value: result });
				return result;
			},
			get superClass() {
				const result = superClassPosition === 0 ? null : convertNode(superClassPosition, buffer);
				Object.defineProperty(node, 'superClass', { value: result });
				return result;
			},
			get body() {
				const result = convertNode(buffer[position + 5], buffer);
				Object.defineProperty(node, 'body', { value: result });
				return result;
			}
		};
		return node;
	},
	function classExpression(position, buffer): ast.ClassExpression {
		const idPosition = buffer[position + 3];
		const superClassPosition = buffer[position + 4];
		const node: ast.ClassExpression = {
			type: 'ClassExpression',
			start: buffer[position],
			end: buffer[position + 1],
			get decorators() {
				const result = convertNodeList(buffer[position + 2], buffer);
				Object.defineProperty(node, 'decorators', { value: result });
				return result;
			},
			get id() {
				const result = idPosition === 0 ? null : convertNode(idPosition, buffer);
				Object.defineProperty(node, 'id', { value: result });
				return result;
			},
			get superClass() {
				const result = superClassPosition === 0 ? null : convertNode(superClassPosition, buffer);
				Object.defineProperty(node, 'superClass', { value: result });
				return result;
			},
			get body() {
				const result = convertNode(buffer[position + 5], buffer);
				Object.defineProperty(node, 'body', { value: result });
				return result;
			}
		};
		return node;
	},
	function conditionalExpression(position, buffer): ast.ConditionalExpression {
		const node: ast.ConditionalExpression = {
			type: 'ConditionalExpression',
			start: buffer[position],
			end: buffer[position + 1],
			get test() {
				const result = convertNode(buffer[position + 2], buffer);
				Object.defineProperty(node, 'test', { value: result });
				return result;
			},
			get consequent() {
				const result = convertNode(buffer[position + 3], buffer);
				Object.defineProperty(node, 'consequent', { value: result });
				return result;
			},
			get alternate() {
				const result = convertNode(buffer[position + 4], buffer);
				Object.defineProperty(node, 'alternate', { value: result });
				return result;
			}
		};
		return node;
	},
	function continueStatement(position, buffer): ast.ContinueStatement {
		const labelPosition = buffer[position + 2];
		const node: ast.ContinueStatement = {
			type: 'ContinueStatement',
			start: buffer[position],
			end: buffer[position + 1],
			get label() {
				const result = labelPosition === 0 ? null : convertNode(labelPosition, buffer);
				Object.defineProperty(node, 'label', { value: result });
				return result;
			}
		};
		return node;
	},
	function debuggerStatement(position, buffer): ast.DebuggerStatement {
		const node: ast.DebuggerStatement = {
			type: 'DebuggerStatement',
			start: buffer[position],
			end: buffer[position + 1]
		};
		return node;
	},
	function decorator(position, buffer): ast.Decorator {
		const node: ast.Decorator = {
			type: 'Decorator',
			start: buffer[position],
			end: buffer[position + 1],
			get expression() {
				const result = convertNode(buffer[position + 2], buffer);
				Object.defineProperty(node, 'expression', { value: result });
				return result;
			}
		};
		return node;
	},
	function directive(position, buffer): ast.Directive {
		const node: ast.Directive = {
			type: 'ExpressionStatement',
			start: buffer[position],
			end: buffer[position + 1],
			get directive() {
				const result = buffer.convertString(buffer[position + 2]);
				Object.defineProperty(node, 'directive', { value: result });
				return result;
			},
			get expression() {
				const result = convertNode(buffer[position + 3], buffer);
				Object.defineProperty(node, 'expression', { value: result });
				return result;
			}
		};
		return node;
	},
	function doWhileStatement(position, buffer): ast.DoWhileStatement {
		const node: ast.DoWhileStatement = {
			type: 'DoWhileStatement',
			start: buffer[position],
			end: buffer[position + 1],
			get body() {
				const result = convertNode(buffer[position + 2], buffer);
				Object.defineProperty(node, 'body', { value: result });
				return result;
			},
			get test() {
				const result = convertNode(buffer[position + 3], buffer);
				Object.defineProperty(node, 'test', { value: result });
				return result;
			}
		};
		return node;
	},
	function emptyStatement(position, buffer): ast.EmptyStatement {
		const node: ast.EmptyStatement = {
			type: 'EmptyStatement',
			start: buffer[position],
			end: buffer[position + 1]
		};
		return node;
	},
	function exportAllDeclaration(position, buffer): ast.ExportAllDeclaration {
		const exportedPosition = buffer[position + 2];
		const node: ast.ExportAllDeclaration = {
			type: 'ExportAllDeclaration',
			start: buffer[position],
			end: buffer[position + 1],
			get exported() {
				const result = exportedPosition === 0 ? null : convertNode(exportedPosition, buffer);
				Object.defineProperty(node, 'exported', { value: result });
				return result;
			},
			get source() {
				const result = convertNode(buffer[position + 3], buffer);
				Object.defineProperty(node, 'source', { value: result });
				return result;
			},
			get attributes() {
				const result = convertNodeList(buffer[position + 4], buffer);
				Object.defineProperty(node, 'attributes', { value: result });
				return result;
			}
		};
		return node;
	},
	function exportDefaultDeclaration(position, buffer): ast.ExportDefaultDeclaration {
		const node: ast.ExportDefaultDeclaration = {
			type: 'ExportDefaultDeclaration',
			start: buffer[position],
			end: buffer[position + 1],
			get declaration() {
				const result = convertNode(buffer[position + 2], buffer);
				Object.defineProperty(node, 'declaration', { value: result });
				return result;
			}
		};
		return node;
	},
	function exportNamedDeclaration(position, buffer): ast.ExportNamedDeclaration {
		const sourcePosition = buffer[position + 3];
		const declarationPosition = buffer[position + 5];
		const node: ast.ExportNamedDeclaration = {
			type: 'ExportNamedDeclaration',
			start: buffer[position],
			end: buffer[position + 1],
			get specifiers() {
				const result = convertNodeList(buffer[position + 2], buffer);
				Object.defineProperty(node, 'specifiers', { value: result });
				return result;
			},
			get source() {
				const result = sourcePosition === 0 ? null : convertNode(sourcePosition, buffer);
				Object.defineProperty(node, 'source', { value: result });
				return result;
			},
			get attributes() {
				const result = convertNodeList(buffer[position + 4], buffer);
				Object.defineProperty(node, 'attributes', { value: result });
				return result;
			},
			get declaration() {
				const result = declarationPosition === 0 ? null : convertNode(declarationPosition, buffer);
				Object.defineProperty(node, 'declaration', { value: result });
				return result;
			}
		};
		return node;
	},
	function exportSpecifier(position, buffer): ast.ExportSpecifier {
		const local = convertNode(buffer[position + 2], buffer);
		const exportedPosition = buffer[position + 3];
		const node: ast.ExportSpecifier = {
			type: 'ExportSpecifier',
			start: buffer[position],
			end: buffer[position + 1],
			local,
			get exported() {
				const result =
					exportedPosition === 0 ? { ...local } : convertNode(exportedPosition, buffer);
				Object.defineProperty(node, 'exported', { value: result });
				return result;
			}
		};
		return node;
	},
	function expressionStatement(position, buffer): ast.ExpressionStatement {
		const node: ast.ExpressionStatement = {
			type: 'ExpressionStatement',
			start: buffer[position],
			end: buffer[position + 1],
			get expression() {
				const result = convertNode(buffer[position + 2], buffer);
				Object.defineProperty(node, 'expression', { value: result });
				return result;
			}
		};
		return node;
	},
	function forInStatement(position, buffer): ast.ForInStatement {
		const node: ast.ForInStatement = {
			type: 'ForInStatement',
			start: buffer[position],
			end: buffer[position + 1],
			get left() {
				const result = convertNode(buffer[position + 2], buffer);
				Object.defineProperty(node, 'left', { value: result });
				return result;
			},
			get right() {
				const result = convertNode(buffer[position + 3], buffer);
				Object.defineProperty(node, 'right', { value: result });
				return result;
			},
			get body() {
				const result = convertNode(buffer[position + 4], buffer);
				Object.defineProperty(node, 'body', { value: result });
				return result;
			}
		};
		return node;
	},
	function forOfStatement(position, buffer): ast.ForOfStatement {
		const flags = buffer[position + 2];
		const node: ast.ForOfStatement = {
			type: 'ForOfStatement',
			start: buffer[position],
			end: buffer[position + 1],
			await: (flags & 1) === 1,
			get left() {
				const result = convertNode(buffer[position + 3], buffer);
				Object.defineProperty(node, 'left', { value: result });
				return result;
			},
			get right() {
				const result = convertNode(buffer[position + 4], buffer);
				Object.defineProperty(node, 'right', { value: result });
				return result;
			},
			get body() {
				const result = convertNode(buffer[position + 5], buffer);
				Object.defineProperty(node, 'body', { value: result });
				return result;
			}
		};
		return node;
	},
	function forStatement(position, buffer): ast.ForStatement {
		const initPosition = buffer[position + 2];
		const testPosition = buffer[position + 3];
		const updatePosition = buffer[position + 4];
		const node: ast.ForStatement = {
			type: 'ForStatement',
			start: buffer[position],
			end: buffer[position + 1],
			get init() {
				const result = initPosition === 0 ? null : convertNode(initPosition, buffer);
				Object.defineProperty(node, 'init', { value: result });
				return result;
			},
			get test() {
				const result = testPosition === 0 ? null : convertNode(testPosition, buffer);
				Object.defineProperty(node, 'test', { value: result });
				return result;
			},
			get update() {
				const result = updatePosition === 0 ? null : convertNode(updatePosition, buffer);
				Object.defineProperty(node, 'update', { value: result });
				return result;
			},
			get body() {
				const result = convertNode(buffer[position + 5], buffer);
				Object.defineProperty(node, 'body', { value: result });
				return result;
			}
		};
		return node;
	},
	function functionDeclaration(position, buffer): ast.FunctionDeclaration {
		const flags = buffer[position + 2];
		const annotations = convertAnnotations(buffer[position + 3], buffer);
		const idPosition = buffer[position + 4];
		const node: ast.FunctionDeclaration = {
			type: 'FunctionDeclaration',
			start: buffer[position],
			end: buffer[position + 1],
			async: (flags & 1) === 1,
			generator: (flags & 2) === 2,
			...(annotations.length > 0 ? { annotations } : {}),
			get id() {
				const result = idPosition === 0 ? null : convertNode(idPosition, buffer);
				Object.defineProperty(node, 'id', { value: result });
				return result;
			},
			get params() {
				const result = convertNodeList(buffer[position + 5], buffer);
				Object.defineProperty(node, 'params', { value: result });
				return result;
			},
			get body() {
				const result = convertNode(buffer[position + 6], buffer);
				Object.defineProperty(node, 'body', { value: result });
				return result;
			},
			expression: false
		};
		return node;
	},
	function functionExpression(position, buffer): ast.FunctionExpression {
		const flags = buffer[position + 2];
		const annotations = convertAnnotations(buffer[position + 3], buffer);
		const idPosition = buffer[position + 4];
		const node: ast.FunctionExpression = {
			type: 'FunctionExpression',
			start: buffer[position],
			end: buffer[position + 1],
			async: (flags & 1) === 1,
			generator: (flags & 2) === 2,
			...(annotations.length > 0 ? { annotations } : {}),
			get id() {
				const result = idPosition === 0 ? null : convertNode(idPosition, buffer);
				Object.defineProperty(node, 'id', { value: result });
				return result;
			},
			get params() {
				const result = convertNodeList(buffer[position + 5], buffer);
				Object.defineProperty(node, 'params', { value: result });
				return result;
			},
			get body() {
				const result = convertNode(buffer[position + 6], buffer);
				Object.defineProperty(node, 'body', { value: result });
				return result;
			},
			expression: false
		};
		return node;
	},
	function identifier(position, buffer): ast.Identifier {
		const node: ast.Identifier = {
			type: 'Identifier',
			start: buffer[position],
			end: buffer[position + 1],
			get name() {
				const result = buffer.convertString(buffer[position + 2]);
				Object.defineProperty(node, 'name', { value: result });
				return result;
			}
		};
		return node;
	},
	function ifStatement(position, buffer): ast.IfStatement {
		const alternatePosition = buffer[position + 4];
		const node: ast.IfStatement = {
			type: 'IfStatement',
			start: buffer[position],
			end: buffer[position + 1],
			get test() {
				const result = convertNode(buffer[position + 2], buffer);
				Object.defineProperty(node, 'test', { value: result });
				return result;
			},
			get consequent() {
				const result = convertNode(buffer[position + 3], buffer);
				Object.defineProperty(node, 'consequent', { value: result });
				return result;
			},
			get alternate() {
				const result = alternatePosition === 0 ? null : convertNode(alternatePosition, buffer);
				Object.defineProperty(node, 'alternate', { value: result });
				return result;
			}
		};
		return node;
	},
	function importAttribute(position, buffer): ast.ImportAttribute {
		const node: ast.ImportAttribute = {
			type: 'ImportAttribute',
			start: buffer[position],
			end: buffer[position + 1],
			get key() {
				const result = convertNode(buffer[position + 2], buffer);
				Object.defineProperty(node, 'key', { value: result });
				return result;
			},
			get value() {
				const result = convertNode(buffer[position + 3], buffer);
				Object.defineProperty(node, 'value', { value: result });
				return result;
			}
		};
		return node;
	},
	function importDeclaration(position, buffer): ast.ImportDeclaration {
		const node: ast.ImportDeclaration = {
			type: 'ImportDeclaration',
			start: buffer[position],
			end: buffer[position + 1],
			get specifiers() {
				const result = convertNodeList(buffer[position + 2], buffer);
				Object.defineProperty(node, 'specifiers', { value: result });
				return result;
			},
			get source() {
				const result = convertNode(buffer[position + 3], buffer);
				Object.defineProperty(node, 'source', { value: result });
				return result;
			},
			get attributes() {
				const result = convertNodeList(buffer[position + 4], buffer);
				Object.defineProperty(node, 'attributes', { value: result });
				return result;
			}
		};
		return node;
	},
	function importDefaultSpecifier(position, buffer): ast.ImportDefaultSpecifier {
		const node: ast.ImportDefaultSpecifier = {
			type: 'ImportDefaultSpecifier',
			start: buffer[position],
			end: buffer[position + 1],
			get local() {
				const result = convertNode(buffer[position + 2], buffer);
				Object.defineProperty(node, 'local', { value: result });
				return result;
			}
		};
		return node;
	},
	function importExpression(position, buffer): ast.ImportExpression {
		const optionsPosition = buffer[position + 3];
		const node: ast.ImportExpression = {
			type: 'ImportExpression',
			start: buffer[position],
			end: buffer[position + 1],
			get source() {
				const result = convertNode(buffer[position + 2], buffer);
				Object.defineProperty(node, 'source', { value: result });
				return result;
			},
			get options() {
				const result = optionsPosition === 0 ? null : convertNode(optionsPosition, buffer);
				Object.defineProperty(node, 'options', { value: result });
				return result;
			}
		};
		return node;
	},
	function importNamespaceSpecifier(position, buffer): ast.ImportNamespaceSpecifier {
		const node: ast.ImportNamespaceSpecifier = {
			type: 'ImportNamespaceSpecifier',
			start: buffer[position],
			end: buffer[position + 1],
			get local() {
				const result = convertNode(buffer[position + 2], buffer);
				Object.defineProperty(node, 'local', { value: result });
				return result;
			}
		};
		return node;
	},
	function importSpecifier(position, buffer): ast.ImportSpecifier {
		const importedPosition = buffer[position + 2];
		const local = convertNode(buffer[position + 3], buffer);
		const node: ast.ImportSpecifier = {
			type: 'ImportSpecifier',
			start: buffer[position],
			end: buffer[position + 1],
			get imported() {
				const result =
					importedPosition === 0 ? { ...local } : convertNode(importedPosition, buffer);
				Object.defineProperty(node, 'imported', { value: result });
				return result;
			},
			local
		};
		return node;
	},
	function jsxAttribute(position, buffer): ast.JSXAttribute {
		const valuePosition = buffer[position + 3];
		const node: ast.JSXAttribute = {
			type: 'JSXAttribute',
			start: buffer[position],
			end: buffer[position + 1],
			get name() {
				const result = convertNode(buffer[position + 2], buffer);
				Object.defineProperty(node, 'name', { value: result });
				return result;
			},
			get value() {
				const result = valuePosition === 0 ? null : convertNode(valuePosition, buffer);
				Object.defineProperty(node, 'value', { value: result });
				return result;
			}
		};
		return node;
	},
	function jsxClosingElement(position, buffer): ast.JSXClosingElement {
		const node: ast.JSXClosingElement = {
			type: 'JSXClosingElement',
			start: buffer[position],
			end: buffer[position + 1],
			get name() {
				const result = convertNode(buffer[position + 2], buffer);
				Object.defineProperty(node, 'name', { value: result });
				return result;
			}
		};
		return node;
	},
	function jsxClosingFragment(position, buffer): ast.JSXClosingFragment {
		const node: ast.JSXClosingFragment = {
			type: 'JSXClosingFragment',
			start: buffer[position],
			end: buffer[position + 1]
		};
		return node;
	},
	function jsxElement(position, buffer): ast.JSXElement {
		const closingElementPosition = buffer[position + 4];
		const node: ast.JSXElement = {
			type: 'JSXElement',
			start: buffer[position],
			end: buffer[position + 1],
			get openingElement() {
				const result = convertNode(buffer[position + 2], buffer);
				Object.defineProperty(node, 'openingElement', { value: result });
				return result;
			},
			get children() {
				const result = convertNodeList(buffer[position + 3], buffer);
				Object.defineProperty(node, 'children', { value: result });
				return result;
			},
			get closingElement() {
				const result =
					closingElementPosition === 0 ? null : convertNode(closingElementPosition, buffer);
				Object.defineProperty(node, 'closingElement', { value: result });
				return result;
			}
		};
		return node;
	},
	function jsxEmptyExpression(position, buffer): ast.JSXEmptyExpression {
		const node: ast.JSXEmptyExpression = {
			type: 'JSXEmptyExpression',
			start: buffer[position],
			end: buffer[position + 1]
		};
		return node;
	},
	function jsxExpressionContainer(position, buffer): ast.JSXExpressionContainer {
		const node: ast.JSXExpressionContainer = {
			type: 'JSXExpressionContainer',
			start: buffer[position],
			end: buffer[position + 1],
			get expression() {
				const result = convertNode(buffer[position + 2], buffer);
				Object.defineProperty(node, 'expression', { value: result });
				return result;
			}
		};
		return node;
	},
	function jsxFragment(position, buffer): ast.JSXFragment {
		const node: ast.JSXFragment = {
			type: 'JSXFragment',
			start: buffer[position],
			end: buffer[position + 1],
			get openingFragment() {
				const result = convertNode(buffer[position + 2], buffer);
				Object.defineProperty(node, 'openingFragment', { value: result });
				return result;
			},
			get children() {
				const result = convertNodeList(buffer[position + 3], buffer);
				Object.defineProperty(node, 'children', { value: result });
				return result;
			},
			get closingFragment() {
				const result = convertNode(buffer[position + 4], buffer);
				Object.defineProperty(node, 'closingFragment', { value: result });
				return result;
			}
		};
		return node;
	},
	function jsxIdentifier(position, buffer): ast.JSXIdentifier {
		const node: ast.JSXIdentifier = {
			type: 'JSXIdentifier',
			start: buffer[position],
			end: buffer[position + 1],
			get name() {
				const result = buffer.convertString(buffer[position + 2]);
				Object.defineProperty(node, 'name', { value: result });
				return result;
			}
		};
		return node;
	},
	function jsxMemberExpression(position, buffer): ast.JSXMemberExpression {
		const node: ast.JSXMemberExpression = {
			type: 'JSXMemberExpression',
			start: buffer[position],
			end: buffer[position + 1],
			get object() {
				const result = convertNode(buffer[position + 2], buffer);
				Object.defineProperty(node, 'object', { value: result });
				return result;
			},
			get property() {
				const result = convertNode(buffer[position + 3], buffer);
				Object.defineProperty(node, 'property', { value: result });
				return result;
			}
		};
		return node;
	},
	function jsxNamespacedName(position, buffer): ast.JSXNamespacedName {
		const node: ast.JSXNamespacedName = {
			type: 'JSXNamespacedName',
			start: buffer[position],
			end: buffer[position + 1],
			get namespace() {
				const result = convertNode(buffer[position + 2], buffer);
				Object.defineProperty(node, 'namespace', { value: result });
				return result;
			},
			get name() {
				const result = convertNode(buffer[position + 3], buffer);
				Object.defineProperty(node, 'name', { value: result });
				return result;
			}
		};
		return node;
	},
	function jsxOpeningElement(position, buffer): ast.JSXOpeningElement {
		const flags = buffer[position + 2];
		const node: ast.JSXOpeningElement = {
			type: 'JSXOpeningElement',
			start: buffer[position],
			end: buffer[position + 1],
			selfClosing: (flags & 1) === 1,
			get name() {
				const result = convertNode(buffer[position + 3], buffer);
				Object.defineProperty(node, 'name', { value: result });
				return result;
			},
			get attributes() {
				const result = convertNodeList(buffer[position + 4], buffer);
				Object.defineProperty(node, 'attributes', { value: result });
				return result;
			}
		};
		return node;
	},
	function jsxOpeningFragment(position, buffer): ast.JSXOpeningFragment {
		const node: ast.JSXOpeningFragment = {
			type: 'JSXOpeningFragment',
			start: buffer[position],
			end: buffer[position + 1],
			attributes: [],
			selfClosing: false
		};
		return node;
	},
	function jsxSpreadAttribute(position, buffer): ast.JSXSpreadAttribute {
		const node: ast.JSXSpreadAttribute = {
			type: 'JSXSpreadAttribute',
			start: buffer[position],
			end: buffer[position + 1],
			get argument() {
				const result = convertNode(buffer[position + 2], buffer);
				Object.defineProperty(node, 'argument', { value: result });
				return result;
			}
		};
		return node;
	},
	function jsxSpreadChild(position, buffer): ast.JSXSpreadChild {
		const node: ast.JSXSpreadChild = {
			type: 'JSXSpreadChild',
			start: buffer[position],
			end: buffer[position + 1],
			get expression() {
				const result = convertNode(buffer[position + 2], buffer);
				Object.defineProperty(node, 'expression', { value: result });
				return result;
			}
		};
		return node;
	},
	function jsxText(position, buffer): ast.JSXText {
		const node: ast.JSXText = {
			type: 'JSXText',
			start: buffer[position],
			end: buffer[position + 1],
			get value() {
				const result = buffer.convertString(buffer[position + 2]);
				Object.defineProperty(node, 'value', { value: result });
				return result;
			},
			get raw() {
				const result = buffer.convertString(buffer[position + 3]);
				Object.defineProperty(node, 'raw', { value: result });
				return result;
			}
		};
		return node;
	},
	function labeledStatement(position, buffer): ast.LabeledStatement {
		const node: ast.LabeledStatement = {
			type: 'LabeledStatement',
			start: buffer[position],
			end: buffer[position + 1],
			get label() {
				const result = convertNode(buffer[position + 2], buffer);
				Object.defineProperty(node, 'label', { value: result });
				return result;
			},
			get body() {
				const result = convertNode(buffer[position + 3], buffer);
				Object.defineProperty(node, 'body', { value: result });
				return result;
			}
		};
		return node;
	},
	function literalBigInt(position, buffer): ast.LiteralBigInt {
		const bigint = buffer.convertString(buffer[position + 2]);
		const node: ast.LiteralBigInt = {
			type: 'Literal',
			start: buffer[position],
			end: buffer[position + 1],
			bigint,
			get raw() {
				const result = buffer.convertString(buffer[position + 3]);
				Object.defineProperty(node, 'raw', { value: result });
				return result;
			},
			value: BigInt(bigint)
		};
		return node;
	},
	function literalBoolean(position, buffer): ast.LiteralBoolean {
		const flags = buffer[position + 2];
		const value = (flags & 1) === 1;
		const node: ast.LiteralBoolean = {
			type: 'Literal',
			start: buffer[position],
			end: buffer[position + 1],
			value,
			raw: value ? 'true' : 'false'
		};
		return node;
	},
	function literalNull(position, buffer): ast.LiteralNull {
		const node: ast.LiteralNull = {
			type: 'Literal',
			start: buffer[position],
			end: buffer[position + 1],
			raw: 'null',
			value: null
		};
		return node;
	},
	function literalNumber(position, buffer): ast.LiteralNumber {
		const rawPosition = buffer[position + 2];
		const node: ast.LiteralNumber = {
			type: 'Literal',
			start: buffer[position],
			end: buffer[position + 1],
			get raw() {
				const result = rawPosition === 0 ? undefined : buffer.convertString(rawPosition);
				Object.defineProperty(node, 'raw', { value: result });
				return result;
			},
			get value() {
				const result = new DataView(buffer.buffer).getFloat64((position + 3) << 2, true);
				Object.defineProperty(node, 'value', { value: result });
				return result;
			}
		};
		return node;
	},
	function literalRegExp(position, buffer): ast.LiteralRegExp {
		const flags = buffer.convertString(buffer[position + 2]);
		const pattern = buffer.convertString(buffer[position + 3]);
		const node: ast.LiteralRegExp = {
			type: 'Literal',
			start: buffer[position],
			end: buffer[position + 1],
			raw: `/${pattern}/${flags}`,
			regex: { flags, pattern },
			value: new RegExp(pattern, flags)
		};
		return node;
	},
	function literalString(position, buffer): ast.LiteralString {
		const rawPosition = buffer[position + 3];
		const node: ast.LiteralString = {
			type: 'Literal',
			start: buffer[position],
			end: buffer[position + 1],
			get value() {
				const result = buffer.convertString(buffer[position + 2]);
				Object.defineProperty(node, 'value', { value: result });
				return result;
			},
			get raw() {
				const result = rawPosition === 0 ? undefined : buffer.convertString(rawPosition);
				Object.defineProperty(node, 'raw', { value: result });
				return result;
			}
		};
		return node;
	},
	function logicalExpression(position, buffer): ast.LogicalExpression {
		const node: ast.LogicalExpression = {
			type: 'LogicalExpression',
			start: buffer[position],
			end: buffer[position + 1],
			get operator() {
				const result = FIXED_STRINGS[buffer[position + 2]] as ast.LogicalExpression['operator'];
				Object.defineProperty(node, 'operator', { value: result });
				return result;
			},
			get left() {
				const result = convertNode(buffer[position + 3], buffer);
				Object.defineProperty(node, 'left', { value: result });
				return result;
			},
			get right() {
				const result = convertNode(buffer[position + 4], buffer);
				Object.defineProperty(node, 'right', { value: result });
				return result;
			}
		};
		return node;
	},
	function memberExpression(position, buffer): ast.MemberExpression {
		const flags = buffer[position + 2];
		const node: ast.MemberExpression = {
			type: 'MemberExpression',
			start: buffer[position],
			end: buffer[position + 1],
			computed: (flags & 1) === 1,
			optional: (flags & 2) === 2,
			get object() {
				const result = convertNode(buffer[position + 3], buffer);
				Object.defineProperty(node, 'object', { value: result });
				return result;
			},
			get property() {
				const result = convertNode(buffer[position + 4], buffer);
				Object.defineProperty(node, 'property', { value: result });
				return result;
			}
		};
		return node;
	},
	function metaProperty(position, buffer): ast.MetaProperty {
		const node: ast.MetaProperty = {
			type: 'MetaProperty',
			start: buffer[position],
			end: buffer[position + 1],
			get meta() {
				const result = convertNode(buffer[position + 2], buffer);
				Object.defineProperty(node, 'meta', { value: result });
				return result;
			},
			get property() {
				const result = convertNode(buffer[position + 3], buffer);
				Object.defineProperty(node, 'property', { value: result });
				return result;
			}
		};
		return node;
	},
	function methodDefinition(position, buffer): ast.MethodDefinition {
		const flags = buffer[position + 2];
		const node: ast.MethodDefinition = {
			type: 'MethodDefinition',
			start: buffer[position],
			end: buffer[position + 1],
			static: (flags & 1) === 1,
			computed: (flags & 2) === 2,
			get decorators() {
				const result = convertNodeList(buffer[position + 3], buffer);
				Object.defineProperty(node, 'decorators', { value: result });
				return result;
			},
			get key() {
				const result = convertNode(buffer[position + 4], buffer);
				Object.defineProperty(node, 'key', { value: result });
				return result;
			},
			get value() {
				const result = convertNode(buffer[position + 5], buffer);
				Object.defineProperty(node, 'value', { value: result });
				return result;
			},
			get kind() {
				const result = FIXED_STRINGS[buffer[position + 6]] as ast.MethodDefinition['kind'];
				Object.defineProperty(node, 'kind', { value: result });
				return result;
			}
		};
		return node;
	},
	function newExpression(position, buffer): ast.NewExpression {
		const annotations = convertAnnotations(buffer[position + 2], buffer);
		const node: ast.NewExpression = {
			type: 'NewExpression',
			start: buffer[position],
			end: buffer[position + 1],
			...(annotations.length > 0 ? { annotations } : {}),
			get callee() {
				const result = convertNode(buffer[position + 3], buffer);
				Object.defineProperty(node, 'callee', { value: result });
				return result;
			},
			get arguments() {
				const result = convertNodeList(buffer[position + 4], buffer);
				Object.defineProperty(node, 'arguments', { value: result });
				return result;
			}
		};
		return node;
	},
	function objectExpression(position, buffer): ast.ObjectExpression {
		const node: ast.ObjectExpression = {
			type: 'ObjectExpression',
			start: buffer[position],
			end: buffer[position + 1],
			get properties() {
				const result = convertNodeList(buffer[position + 2], buffer);
				Object.defineProperty(node, 'properties', { value: result });
				return result;
			}
		};
		return node;
	},
	function objectPattern(position, buffer): ast.ObjectPattern {
		const node: ast.ObjectPattern = {
			type: 'ObjectPattern',
			start: buffer[position],
			end: buffer[position + 1],
			get properties() {
				const result = convertNodeList(buffer[position + 2], buffer);
				Object.defineProperty(node, 'properties', { value: result });
				return result;
			}
		};
		return node;
	},
	function privateIdentifier(position, buffer): ast.PrivateIdentifier {
		const node: ast.PrivateIdentifier = {
			type: 'PrivateIdentifier',
			start: buffer[position],
			end: buffer[position + 1],
			get name() {
				const result = buffer.convertString(buffer[position + 2]);
				Object.defineProperty(node, 'name', { value: result });
				return result;
			}
		};
		return node;
	},
	function program(position, buffer): ast.Program {
		const invalidAnnotations = convertAnnotations(buffer[position + 3], buffer);
		const node: ast.Program = {
			type: 'Program',
			start: buffer[position],
			end: buffer[position + 1],
			get body() {
				const result = convertNodeList(buffer[position + 2], buffer);
				Object.defineProperty(node, 'body', { value: result });
				return result;
			},
			...(invalidAnnotations.length > 0 ? { invalidAnnotations } : {}),
			sourceType: 'module'
		};
		return node;
	},
	function property(position, buffer): ast.Property {
		const flags = buffer[position + 2];
		const keyPosition = buffer[position + 3];
		const value = convertNode(buffer[position + 4], buffer);
		const node: ast.Property = {
			type: 'Property',
			start: buffer[position],
			end: buffer[position + 1],
			method: (flags & 1) === 1,
			shorthand: (flags & 2) === 2,
			computed: (flags & 4) === 4,
			get key() {
				const result = keyPosition === 0 ? { ...value } : convertNode(keyPosition, buffer);
				Object.defineProperty(node, 'key', { value: result });
				return result;
			},
			value,
			get kind() {
				const result = FIXED_STRINGS[buffer[position + 5]] as ast.Property['kind'];
				Object.defineProperty(node, 'kind', { value: result });
				return result;
			}
		};
		return node;
	},
	function propertyDefinition(position, buffer): ast.PropertyDefinition {
		const flags = buffer[position + 2];
		const valuePosition = buffer[position + 5];
		const node: ast.PropertyDefinition = {
			type: 'PropertyDefinition',
			start: buffer[position],
			end: buffer[position + 1],
			static: (flags & 1) === 1,
			computed: (flags & 2) === 2,
			get decorators() {
				const result = convertNodeList(buffer[position + 3], buffer);
				Object.defineProperty(node, 'decorators', { value: result });
				return result;
			},
			get key() {
				const result = convertNode(buffer[position + 4], buffer);
				Object.defineProperty(node, 'key', { value: result });
				return result;
			},
			get value() {
				const result = valuePosition === 0 ? null : convertNode(valuePosition, buffer);
				Object.defineProperty(node, 'value', { value: result });
				return result;
			}
		};
		return node;
	},
	function restElement(position, buffer): ast.RestElement {
		const node: ast.RestElement = {
			type: 'RestElement',
			start: buffer[position],
			end: buffer[position + 1],
			get argument() {
				const result = convertNode(buffer[position + 2], buffer);
				Object.defineProperty(node, 'argument', { value: result });
				return result;
			}
		};
		return node;
	},
	function returnStatement(position, buffer): ast.ReturnStatement {
		const argumentPosition = buffer[position + 2];
		const node: ast.ReturnStatement = {
			type: 'ReturnStatement',
			start: buffer[position],
			end: buffer[position + 1],
			get argument() {
				const result = argumentPosition === 0 ? null : convertNode(argumentPosition, buffer);
				Object.defineProperty(node, 'argument', { value: result });
				return result;
			}
		};
		return node;
	},
	function sequenceExpression(position, buffer): ast.SequenceExpression {
		const node: ast.SequenceExpression = {
			type: 'SequenceExpression',
			start: buffer[position],
			end: buffer[position + 1],
			get expressions() {
				const result = convertNodeList(buffer[position + 2], buffer);
				Object.defineProperty(node, 'expressions', { value: result });
				return result;
			}
		};
		return node;
	},
	function spreadElement(position, buffer): ast.SpreadElement {
		const node: ast.SpreadElement = {
			type: 'SpreadElement',
			start: buffer[position],
			end: buffer[position + 1],
			get argument() {
				const result = convertNode(buffer[position + 2], buffer);
				Object.defineProperty(node, 'argument', { value: result });
				return result;
			}
		};
		return node;
	},
	function staticBlock(position, buffer): ast.StaticBlock {
		const node: ast.StaticBlock = {
			type: 'StaticBlock',
			start: buffer[position],
			end: buffer[position + 1],
			get body() {
				const result = convertNodeList(buffer[position + 2], buffer);
				Object.defineProperty(node, 'body', { value: result });
				return result;
			}
		};
		return node;
	},
	function superElement(position, buffer): ast.Super {
		const node: ast.Super = {
			type: 'Super',
			start: buffer[position],
			end: buffer[position + 1]
		};
		return node;
	},
	function switchCase(position, buffer): ast.SwitchCase {
		const testPosition = buffer[position + 2];
		const node: ast.SwitchCase = {
			type: 'SwitchCase',
			start: buffer[position],
			end: buffer[position + 1],
			get test() {
				const result = testPosition === 0 ? null : convertNode(testPosition, buffer);
				Object.defineProperty(node, 'test', { value: result });
				return result;
			},
			get consequent() {
				const result = convertNodeList(buffer[position + 3], buffer);
				Object.defineProperty(node, 'consequent', { value: result });
				return result;
			}
		};
		return node;
	},
	function switchStatement(position, buffer): ast.SwitchStatement {
		const node: ast.SwitchStatement = {
			type: 'SwitchStatement',
			start: buffer[position],
			end: buffer[position + 1],
			get discriminant() {
				const result = convertNode(buffer[position + 2], buffer);
				Object.defineProperty(node, 'discriminant', { value: result });
				return result;
			},
			get cases() {
				const result = convertNodeList(buffer[position + 3], buffer);
				Object.defineProperty(node, 'cases', { value: result });
				return result;
			}
		};
		return node;
	},
	function taggedTemplateExpression(position, buffer): ast.TaggedTemplateExpression {
		const node: ast.TaggedTemplateExpression = {
			type: 'TaggedTemplateExpression',
			start: buffer[position],
			end: buffer[position + 1],
			get tag() {
				const result = convertNode(buffer[position + 2], buffer);
				Object.defineProperty(node, 'tag', { value: result });
				return result;
			},
			get quasi() {
				const result = convertNode(buffer[position + 3], buffer);
				Object.defineProperty(node, 'quasi', { value: result });
				return result;
			}
		};
		return node;
	},
	function templateElement(position, buffer): ast.TemplateElement {
		const flags = buffer[position + 2];
		const cookedPosition = buffer[position + 3];
		const cooked = cookedPosition === 0 ? undefined : buffer.convertString(cookedPosition);
		const raw = buffer.convertString(buffer[position + 4]);
		const node: ast.TemplateElement = {
			type: 'TemplateElement',
			start: buffer[position],
			end: buffer[position + 1],
			tail: (flags & 1) === 1,
			value: { cooked, raw }
		};
		return node;
	},
	function templateLiteral(position, buffer): ast.TemplateLiteral {
		const node: ast.TemplateLiteral = {
			type: 'TemplateLiteral',
			start: buffer[position],
			end: buffer[position + 1],
			get quasis() {
				const result = convertNodeList(buffer[position + 2], buffer);
				Object.defineProperty(node, 'quasis', { value: result });
				return result;
			},
			get expressions() {
				const result = convertNodeList(buffer[position + 3], buffer);
				Object.defineProperty(node, 'expressions', { value: result });
				return result;
			}
		};
		return node;
	},
	function thisExpression(position, buffer): ast.ThisExpression {
		const node: ast.ThisExpression = {
			type: 'ThisExpression',
			start: buffer[position],
			end: buffer[position + 1]
		};
		return node;
	},
	function throwStatement(position, buffer): ast.ThrowStatement {
		const node: ast.ThrowStatement = {
			type: 'ThrowStatement',
			start: buffer[position],
			end: buffer[position + 1],
			get argument() {
				const result = convertNode(buffer[position + 2], buffer);
				Object.defineProperty(node, 'argument', { value: result });
				return result;
			}
		};
		return node;
	},
	function tryStatement(position, buffer): ast.TryStatement {
		const handlerPosition = buffer[position + 3];
		const finalizerPosition = buffer[position + 4];
		const node: ast.TryStatement = {
			type: 'TryStatement',
			start: buffer[position],
			end: buffer[position + 1],
			get block() {
				const result = convertNode(buffer[position + 2], buffer);
				Object.defineProperty(node, 'block', { value: result });
				return result;
			},
			get handler() {
				const result = handlerPosition === 0 ? null : convertNode(handlerPosition, buffer);
				Object.defineProperty(node, 'handler', { value: result });
				return result;
			},
			get finalizer() {
				const result = finalizerPosition === 0 ? null : convertNode(finalizerPosition, buffer);
				Object.defineProperty(node, 'finalizer', { value: result });
				return result;
			}
		};
		return node;
	},
	function unaryExpression(position, buffer): ast.UnaryExpression {
		const node: ast.UnaryExpression = {
			type: 'UnaryExpression',
			start: buffer[position],
			end: buffer[position + 1],
			get operator() {
				const result = FIXED_STRINGS[buffer[position + 2]] as ast.UnaryExpression['operator'];
				Object.defineProperty(node, 'operator', { value: result });
				return result;
			},
			get argument() {
				const result = convertNode(buffer[position + 3], buffer);
				Object.defineProperty(node, 'argument', { value: result });
				return result;
			},
			prefix: true
		};
		return node;
	},
	function updateExpression(position, buffer): ast.UpdateExpression {
		const flags = buffer[position + 2];
		const node: ast.UpdateExpression = {
			type: 'UpdateExpression',
			start: buffer[position],
			end: buffer[position + 1],
			prefix: (flags & 1) === 1,
			get operator() {
				const result = FIXED_STRINGS[buffer[position + 3]] as ast.UpdateExpression['operator'];
				Object.defineProperty(node, 'operator', { value: result });
				return result;
			},
			get argument() {
				const result = convertNode(buffer[position + 4], buffer);
				Object.defineProperty(node, 'argument', { value: result });
				return result;
			}
		};
		return node;
	},
	function variableDeclaration(position, buffer): ast.VariableDeclaration {
		const node: ast.VariableDeclaration = {
			type: 'VariableDeclaration',
			start: buffer[position],
			end: buffer[position + 1],
			get kind() {
				const result = FIXED_STRINGS[buffer[position + 2]] as ast.VariableDeclaration['kind'];
				Object.defineProperty(node, 'kind', { value: result });
				return result;
			},
			get declarations() {
				const result = convertNodeList(buffer[position + 3], buffer);
				Object.defineProperty(node, 'declarations', { value: result });
				return result;
			}
		};
		return node;
	},
	function variableDeclarator(position, buffer): ast.VariableDeclarator {
		const initPosition = buffer[position + 3];
		const node: ast.VariableDeclarator = {
			type: 'VariableDeclarator',
			start: buffer[position],
			end: buffer[position + 1],
			get id() {
				const result = convertNode(buffer[position + 2], buffer);
				Object.defineProperty(node, 'id', { value: result });
				return result;
			},
			get init() {
				const result = initPosition === 0 ? null : convertNode(initPosition, buffer);
				Object.defineProperty(node, 'init', { value: result });
				return result;
			}
		};
		return node;
	},
	function whileStatement(position, buffer): ast.WhileStatement {
		const node: ast.WhileStatement = {
			type: 'WhileStatement',
			start: buffer[position],
			end: buffer[position + 1],
			get test() {
				const result = convertNode(buffer[position + 2], buffer);
				Object.defineProperty(node, 'test', { value: result });
				return result;
			},
			get body() {
				const result = convertNode(buffer[position + 3], buffer);
				Object.defineProperty(node, 'body', { value: result });
				return result;
			}
		};
		return node;
	},
	function yieldExpression(position, buffer): ast.YieldExpression {
		const flags = buffer[position + 2];
		const argumentPosition = buffer[position + 3];
		const node: ast.YieldExpression = {
			type: 'YieldExpression',
			start: buffer[position],
			end: buffer[position + 1],
			delegate: (flags & 1) === 1,
			get argument() {
				const result = argumentPosition === 0 ? null : convertNode(argumentPosition, buffer);
				Object.defineProperty(node, 'argument', { value: result });
				return result;
			}
		};
		return node;
	}
];

export function convertNode(position: number, buffer: AstBuffer): any {
	const nodeType = buffer[position];
	const converter = nodeConverters[nodeType];
	/* istanbul ignore if: This should never be executed but is a safeguard against faulty buffers */
	if (!converter) {
		console.trace();
		throw new Error(`Unknown node type: ${nodeType}`);
	}
	return converter(position + 1, buffer);
}

function convertNodeList(position: number, buffer: AstBuffer): readonly any[] {
	if (position === 0) return EMPTY_ARRAY;
	const length = buffer[position++];
	const list: any[] = new Array(length);
	for (let index = 0; index < length; index++) {
		const nodePosition = buffer[position++];
		list[index] = nodePosition ? convertNode(nodePosition, buffer) : null;
	}
	return list;
}
