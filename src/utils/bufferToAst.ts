// This file is generated by scripts/generate-buffer-to-ast.ts.
// Do not edit this file directly.

import { PanicError, ParseError } from '../ast/nodes/NodeType';
import type { ast } from '../rollup/types';
import { convertAnnotations } from './astConverterHelpers';
import { EMPTY_ARRAY } from './blank';
import FIXED_STRINGS from './convert-ast-strings';
import type { AstBuffer } from './getAstBuffer';
import { error, getRollupError, logParseError } from './logs';

export function convertProgram(buffer: AstBuffer): ast.Program {
	const node = convertNode(0, buffer);
	switch (node.type) {
		case PanicError: {
			return error(getRollupError(logParseError(node.message)));
		}
		case ParseError: {
			return error(getRollupError(logParseError(node.message, node.start)));
		}
		default: {
			return node;
		}
	}
}

/* eslint-disable sort-keys */
const nodeConverters: ((position: number, buffer: AstBuffer) => any)[] = [
	function panicError(position, buffer): ast.PanicError {
		return {
			type: 'PanicError',
			start: buffer[position],
			end: buffer[position + 1],
			message: buffer.convertString(buffer[position + 2])
		};
	},
	function parseError(position, buffer): ast.ParseError {
		return {
			type: 'ParseError',
			start: buffer[position],
			end: buffer[position + 1],
			message: buffer.convertString(buffer[position + 2])
		};
	},
	function arrayExpression(position, buffer): ast.ArrayExpression {
		return {
			type: 'ArrayExpression',
			start: buffer[position],
			end: buffer[position + 1],
			elements: convertNodeList(buffer[position + 2], buffer)
		};
	},
	function arrayPattern(position, buffer): ast.ArrayPattern {
		return {
			type: 'ArrayPattern',
			start: buffer[position],
			end: buffer[position + 1],
			elements: convertNodeList(buffer[position + 2], buffer)
		};
	},
	function arrowFunctionExpression(position, buffer): ast.ArrowFunctionExpression {
		const flags = buffer[position + 2];
		const annotations = convertAnnotations(buffer[position + 3], buffer);
		return {
			type: 'ArrowFunctionExpression',
			start: buffer[position],
			end: buffer[position + 1],
			async: (flags & 1) === 1,
			expression: (flags & 2) === 2,
			generator: (flags & 4) === 4,
			...(annotations.length > 0 ? { annotations } : {}),
			params: convertNodeList(buffer[position + 4], buffer),
			body: convertNode(buffer[position + 5], buffer),
			id: null
		};
	},
	function assignmentExpression(position, buffer): ast.AssignmentExpression {
		return {
			type: 'AssignmentExpression',
			start: buffer[position],
			end: buffer[position + 1],
			operator: FIXED_STRINGS[buffer[position + 2]] as ast.AssignmentExpression['operator'],
			left: convertNode(buffer[position + 3], buffer),
			right: convertNode(buffer[position + 4], buffer)
		};
	},
	function assignmentPattern(position, buffer): ast.AssignmentPattern {
		return {
			type: 'AssignmentPattern',
			start: buffer[position],
			end: buffer[position + 1],
			left: convertNode(buffer[position + 2], buffer),
			right: convertNode(buffer[position + 3], buffer)
		};
	},
	function awaitExpression(position, buffer): ast.AwaitExpression {
		return {
			type: 'AwaitExpression',
			start: buffer[position],
			end: buffer[position + 1],
			argument: convertNode(buffer[position + 2], buffer)
		};
	},
	function binaryExpression(position, buffer): ast.BinaryExpression {
		return {
			type: 'BinaryExpression',
			start: buffer[position],
			end: buffer[position + 1],
			operator: FIXED_STRINGS[buffer[position + 2]] as ast.BinaryExpression['operator'],
			left: convertNode(buffer[position + 3], buffer),
			right: convertNode(buffer[position + 4], buffer)
		};
	},
	function blockStatement(position, buffer): ast.BlockStatement {
		return {
			type: 'BlockStatement',
			start: buffer[position],
			end: buffer[position + 1],
			body: convertNodeList(buffer[position + 2], buffer)
		};
	},
	function breakStatement(position, buffer): ast.BreakStatement {
		const labelPosition = buffer[position + 2];
		return {
			type: 'BreakStatement',
			start: buffer[position],
			end: buffer[position + 1],
			label: labelPosition === 0 ? null : convertNode(labelPosition, buffer)
		};
	},
	function callExpression(position, buffer): ast.CallExpression {
		const flags = buffer[position + 2];
		const annotations = convertAnnotations(buffer[position + 3], buffer);
		return {
			type: 'CallExpression',
			start: buffer[position],
			end: buffer[position + 1],
			optional: (flags & 1) === 1,
			...(annotations.length > 0 ? { annotations } : {}),
			callee: convertNode(buffer[position + 4], buffer),
			arguments: convertNodeList(buffer[position + 5], buffer)
		};
	},
	function catchClause(position, buffer): ast.CatchClause {
		const parameterPosition = buffer[position + 2];
		return {
			type: 'CatchClause',
			start: buffer[position],
			end: buffer[position + 1],
			param: parameterPosition === 0 ? null : convertNode(parameterPosition, buffer),
			body: convertNode(buffer[position + 3], buffer)
		};
	},
	function chainExpression(position, buffer): ast.ChainExpression {
		return {
			type: 'ChainExpression',
			start: buffer[position],
			end: buffer[position + 1],
			expression: convertNode(buffer[position + 2], buffer)
		};
	},
	function classBody(position, buffer): ast.ClassBody {
		return {
			type: 'ClassBody',
			start: buffer[position],
			end: buffer[position + 1],
			body: convertNodeList(buffer[position + 2], buffer)
		};
	},
	function classDeclaration(position, buffer): ast.ClassDeclaration {
		const idPosition = buffer[position + 3];
		const superClassPosition = buffer[position + 4];
		return {
			type: 'ClassDeclaration',
			start: buffer[position],
			end: buffer[position + 1],
			decorators: convertNodeList(buffer[position + 2], buffer),
			id: idPosition === 0 ? null : convertNode(idPosition, buffer),
			superClass: superClassPosition === 0 ? null : convertNode(superClassPosition, buffer),
			body: convertNode(buffer[position + 5], buffer)
		};
	},
	function classExpression(position, buffer): ast.ClassExpression {
		const idPosition = buffer[position + 3];
		const superClassPosition = buffer[position + 4];
		return {
			type: 'ClassExpression',
			start: buffer[position],
			end: buffer[position + 1],
			decorators: convertNodeList(buffer[position + 2], buffer),
			id: idPosition === 0 ? null : convertNode(idPosition, buffer),
			superClass: superClassPosition === 0 ? null : convertNode(superClassPosition, buffer),
			body: convertNode(buffer[position + 5], buffer)
		};
	},
	function conditionalExpression(position, buffer): ast.ConditionalExpression {
		return {
			type: 'ConditionalExpression',
			start: buffer[position],
			end: buffer[position + 1],
			test: convertNode(buffer[position + 2], buffer),
			consequent: convertNode(buffer[position + 3], buffer),
			alternate: convertNode(buffer[position + 4], buffer)
		};
	},
	function continueStatement(position, buffer): ast.ContinueStatement {
		const labelPosition = buffer[position + 2];
		return {
			type: 'ContinueStatement',
			start: buffer[position],
			end: buffer[position + 1],
			label: labelPosition === 0 ? null : convertNode(labelPosition, buffer)
		};
	},
	function debuggerStatement(position, buffer): ast.DebuggerStatement {
		return {
			type: 'DebuggerStatement',
			start: buffer[position],
			end: buffer[position + 1]
		};
	},
	function decorator(position, buffer): ast.Decorator {
		return {
			type: 'Decorator',
			start: buffer[position],
			end: buffer[position + 1],
			expression: convertNode(buffer[position + 2], buffer)
		};
	},
	function directive(position, buffer): ast.Directive {
		return {
			type: 'ExpressionStatement',
			start: buffer[position],
			end: buffer[position + 1],
			directive: buffer.convertString(buffer[position + 2]),
			expression: convertNode(buffer[position + 3], buffer)
		};
	},
	function doWhileStatement(position, buffer): ast.DoWhileStatement {
		return {
			type: 'DoWhileStatement',
			start: buffer[position],
			end: buffer[position + 1],
			body: convertNode(buffer[position + 2], buffer),
			test: convertNode(buffer[position + 3], buffer)
		};
	},
	function emptyStatement(position, buffer): ast.EmptyStatement {
		return {
			type: 'EmptyStatement',
			start: buffer[position],
			end: buffer[position + 1]
		};
	},
	function exportAllDeclaration(position, buffer): ast.ExportAllDeclaration {
		const exportedPosition = buffer[position + 2];
		return {
			type: 'ExportAllDeclaration',
			start: buffer[position],
			end: buffer[position + 1],
			exported: exportedPosition === 0 ? null : convertNode(exportedPosition, buffer),
			source: convertNode(buffer[position + 3], buffer),
			attributes: convertNodeList(buffer[position + 4], buffer)
		};
	},
	function exportDefaultDeclaration(position, buffer): ast.ExportDefaultDeclaration {
		return {
			type: 'ExportDefaultDeclaration',
			start: buffer[position],
			end: buffer[position + 1],
			declaration: convertNode(buffer[position + 2], buffer)
		};
	},
	function exportNamedDeclaration(position, buffer): ast.ExportNamedDeclaration {
		const sourcePosition = buffer[position + 3];
		const declarationPosition = buffer[position + 5];
		return {
			type: 'ExportNamedDeclaration',
			start: buffer[position],
			end: buffer[position + 1],
			specifiers: convertNodeList(buffer[position + 2], buffer),
			source: sourcePosition === 0 ? null : convertNode(sourcePosition, buffer),
			attributes: convertNodeList(buffer[position + 4], buffer),
			declaration: declarationPosition === 0 ? null : convertNode(declarationPosition, buffer)
		};
	},
	function exportSpecifier(position, buffer): ast.ExportSpecifier {
		const local = convertNode(buffer[position + 2], buffer);
		const exportedPosition = buffer[position + 3];
		return {
			type: 'ExportSpecifier',
			start: buffer[position],
			end: buffer[position + 1],
			local,
			exported: exportedPosition === 0 ? { ...local } : convertNode(exportedPosition, buffer)
		};
	},
	function expressionStatement(position, buffer): ast.ExpressionStatement {
		return {
			type: 'ExpressionStatement',
			start: buffer[position],
			end: buffer[position + 1],
			expression: convertNode(buffer[position + 2], buffer)
		};
	},
	function forInStatement(position, buffer): ast.ForInStatement {
		return {
			type: 'ForInStatement',
			start: buffer[position],
			end: buffer[position + 1],
			left: convertNode(buffer[position + 2], buffer),
			right: convertNode(buffer[position + 3], buffer),
			body: convertNode(buffer[position + 4], buffer)
		};
	},
	function forOfStatement(position, buffer): ast.ForOfStatement {
		const flags = buffer[position + 2];
		return {
			type: 'ForOfStatement',
			start: buffer[position],
			end: buffer[position + 1],
			await: (flags & 1) === 1,
			left: convertNode(buffer[position + 3], buffer),
			right: convertNode(buffer[position + 4], buffer),
			body: convertNode(buffer[position + 5], buffer)
		};
	},
	function forStatement(position, buffer): ast.ForStatement {
		const initPosition = buffer[position + 2];
		const testPosition = buffer[position + 3];
		const updatePosition = buffer[position + 4];
		return {
			type: 'ForStatement',
			start: buffer[position],
			end: buffer[position + 1],
			init: initPosition === 0 ? null : convertNode(initPosition, buffer),
			test: testPosition === 0 ? null : convertNode(testPosition, buffer),
			update: updatePosition === 0 ? null : convertNode(updatePosition, buffer),
			body: convertNode(buffer[position + 5], buffer)
		};
	},
	function functionDeclaration(position, buffer): ast.FunctionDeclaration {
		const flags = buffer[position + 2];
		const annotations = convertAnnotations(buffer[position + 3], buffer);
		const idPosition = buffer[position + 4];
		return {
			type: 'FunctionDeclaration',
			start: buffer[position],
			end: buffer[position + 1],
			async: (flags & 1) === 1,
			generator: (flags & 2) === 2,
			...(annotations.length > 0 ? { annotations } : {}),
			id: idPosition === 0 ? null : convertNode(idPosition, buffer),
			params: convertNodeList(buffer[position + 5], buffer),
			body: convertNode(buffer[position + 6], buffer),
			expression: false
		};
	},
	function functionExpression(position, buffer): ast.FunctionExpression {
		const flags = buffer[position + 2];
		const annotations = convertAnnotations(buffer[position + 3], buffer);
		const idPosition = buffer[position + 4];
		return {
			type: 'FunctionExpression',
			start: buffer[position],
			end: buffer[position + 1],
			async: (flags & 1) === 1,
			generator: (flags & 2) === 2,
			...(annotations.length > 0 ? { annotations } : {}),
			id: idPosition === 0 ? null : convertNode(idPosition, buffer),
			params: convertNodeList(buffer[position + 5], buffer),
			body: convertNode(buffer[position + 6], buffer),
			expression: false
		};
	},
	function identifier(position, buffer): ast.Identifier {
		return {
			type: 'Identifier',
			start: buffer[position],
			end: buffer[position + 1],
			name: buffer.convertString(buffer[position + 2])
		};
	},
	function ifStatement(position, buffer): ast.IfStatement {
		const alternatePosition = buffer[position + 4];
		return {
			type: 'IfStatement',
			start: buffer[position],
			end: buffer[position + 1],
			test: convertNode(buffer[position + 2], buffer),
			consequent: convertNode(buffer[position + 3], buffer),
			alternate: alternatePosition === 0 ? null : convertNode(alternatePosition, buffer)
		};
	},
	function importAttribute(position, buffer): ast.ImportAttribute {
		return {
			type: 'ImportAttribute',
			start: buffer[position],
			end: buffer[position + 1],
			key: convertNode(buffer[position + 2], buffer),
			value: convertNode(buffer[position + 3], buffer)
		};
	},
	function importDeclaration(position, buffer): ast.ImportDeclaration {
		return {
			type: 'ImportDeclaration',
			start: buffer[position],
			end: buffer[position + 1],
			specifiers: convertNodeList(buffer[position + 2], buffer),
			source: convertNode(buffer[position + 3], buffer),
			attributes: convertNodeList(buffer[position + 4], buffer)
		};
	},
	function importDefaultSpecifier(position, buffer): ast.ImportDefaultSpecifier {
		return {
			type: 'ImportDefaultSpecifier',
			start: buffer[position],
			end: buffer[position + 1],
			local: convertNode(buffer[position + 2], buffer)
		};
	},
	function importExpression(position, buffer): ast.ImportExpression {
		const optionsPosition = buffer[position + 3];
		return {
			type: 'ImportExpression',
			start: buffer[position],
			end: buffer[position + 1],
			source: convertNode(buffer[position + 2], buffer),
			options: optionsPosition === 0 ? null : convertNode(optionsPosition, buffer)
		};
	},
	function importNamespaceSpecifier(position, buffer): ast.ImportNamespaceSpecifier {
		return {
			type: 'ImportNamespaceSpecifier',
			start: buffer[position],
			end: buffer[position + 1],
			local: convertNode(buffer[position + 2], buffer)
		};
	},
	function importSpecifier(position, buffer): ast.ImportSpecifier {
		const importedPosition = buffer[position + 2];
		const local = convertNode(buffer[position + 3], buffer);
		return {
			type: 'ImportSpecifier',
			start: buffer[position],
			end: buffer[position + 1],
			imported: importedPosition === 0 ? { ...local } : convertNode(importedPosition, buffer),
			local
		};
	},
	function jsxAttribute(position, buffer): ast.JSXAttribute {
		const valuePosition = buffer[position + 3];
		return {
			type: 'JSXAttribute',
			start: buffer[position],
			end: buffer[position + 1],
			name: convertNode(buffer[position + 2], buffer),
			value: valuePosition === 0 ? null : convertNode(valuePosition, buffer)
		};
	},
	function jsxClosingElement(position, buffer): ast.JSXClosingElement {
		return {
			type: 'JSXClosingElement',
			start: buffer[position],
			end: buffer[position + 1],
			name: convertNode(buffer[position + 2], buffer)
		};
	},
	function jsxClosingFragment(position, buffer): ast.JSXClosingFragment {
		return {
			type: 'JSXClosingFragment',
			start: buffer[position],
			end: buffer[position + 1]
		};
	},
	function jsxElement(position, buffer): ast.JSXElement {
		const closingElementPosition = buffer[position + 4];
		return {
			type: 'JSXElement',
			start: buffer[position],
			end: buffer[position + 1],
			openingElement: convertNode(buffer[position + 2], buffer),
			children: convertNodeList(buffer[position + 3], buffer),
			closingElement:
				closingElementPosition === 0 ? null : convertNode(closingElementPosition, buffer)
		};
	},
	function jsxEmptyExpression(position, buffer): ast.JSXEmptyExpression {
		return {
			type: 'JSXEmptyExpression',
			start: buffer[position],
			end: buffer[position + 1]
		};
	},
	function jsxExpressionContainer(position, buffer): ast.JSXExpressionContainer {
		return {
			type: 'JSXExpressionContainer',
			start: buffer[position],
			end: buffer[position + 1],
			expression: convertNode(buffer[position + 2], buffer)
		};
	},
	function jsxFragment(position, buffer): ast.JSXFragment {
		return {
			type: 'JSXFragment',
			start: buffer[position],
			end: buffer[position + 1],
			openingFragment: convertNode(buffer[position + 2], buffer),
			children: convertNodeList(buffer[position + 3], buffer),
			closingFragment: convertNode(buffer[position + 4], buffer)
		};
	},
	function jsxIdentifier(position, buffer): ast.JSXIdentifier {
		return {
			type: 'JSXIdentifier',
			start: buffer[position],
			end: buffer[position + 1],
			name: buffer.convertString(buffer[position + 2])
		};
	},
	function jsxMemberExpression(position, buffer): ast.JSXMemberExpression {
		return {
			type: 'JSXMemberExpression',
			start: buffer[position],
			end: buffer[position + 1],
			object: convertNode(buffer[position + 2], buffer),
			property: convertNode(buffer[position + 3], buffer)
		};
	},
	function jsxNamespacedName(position, buffer): ast.JSXNamespacedName {
		return {
			type: 'JSXNamespacedName',
			start: buffer[position],
			end: buffer[position + 1],
			namespace: convertNode(buffer[position + 2], buffer),
			name: convertNode(buffer[position + 3], buffer)
		};
	},
	function jsxOpeningElement(position, buffer): ast.JSXOpeningElement {
		const flags = buffer[position + 2];
		return {
			type: 'JSXOpeningElement',
			start: buffer[position],
			end: buffer[position + 1],
			selfClosing: (flags & 1) === 1,
			name: convertNode(buffer[position + 3], buffer),
			attributes: convertNodeList(buffer[position + 4], buffer)
		};
	},
	function jsxOpeningFragment(position, buffer): ast.JSXOpeningFragment {
		return {
			type: 'JSXOpeningFragment',
			start: buffer[position],
			end: buffer[position + 1],
			attributes: [],
			selfClosing: false
		};
	},
	function jsxSpreadAttribute(position, buffer): ast.JSXSpreadAttribute {
		return {
			type: 'JSXSpreadAttribute',
			start: buffer[position],
			end: buffer[position + 1],
			argument: convertNode(buffer[position + 2], buffer)
		};
	},
	function jsxSpreadChild(position, buffer): ast.JSXSpreadChild {
		return {
			type: 'JSXSpreadChild',
			start: buffer[position],
			end: buffer[position + 1],
			expression: convertNode(buffer[position + 2], buffer)
		};
	},
	function jsxText(position, buffer): ast.JSXText {
		return {
			type: 'JSXText',
			start: buffer[position],
			end: buffer[position + 1],
			value: buffer.convertString(buffer[position + 2]),
			raw: buffer.convertString(buffer[position + 3])
		};
	},
	function labeledStatement(position, buffer): ast.LabeledStatement {
		return {
			type: 'LabeledStatement',
			start: buffer[position],
			end: buffer[position + 1],
			label: convertNode(buffer[position + 2], buffer),
			body: convertNode(buffer[position + 3], buffer)
		};
	},
	function literalBigInt(position, buffer): ast.LiteralBigInt {
		const bigint = buffer.convertString(buffer[position + 2]);
		return {
			type: 'Literal',
			start: buffer[position],
			end: buffer[position + 1],
			bigint,
			raw: buffer.convertString(buffer[position + 3]),
			value: BigInt(bigint)
		};
	},
	function literalBoolean(position, buffer): ast.LiteralBoolean {
		const flags = buffer[position + 2];
		const value = (flags & 1) === 1;
		return {
			type: 'Literal',
			start: buffer[position],
			end: buffer[position + 1],
			value,
			raw: value ? 'true' : 'false'
		};
	},
	function literalNull(position, buffer): ast.LiteralNull {
		return {
			type: 'Literal',
			start: buffer[position],
			end: buffer[position + 1],
			raw: 'null',
			value: null
		};
	},
	function literalNumber(position, buffer): ast.LiteralNumber {
		const rawPosition = buffer[position + 2];
		return {
			type: 'Literal',
			start: buffer[position],
			end: buffer[position + 1],
			raw: rawPosition === 0 ? undefined : buffer.convertString(rawPosition),
			value: new DataView(buffer.buffer).getFloat64((position + 3) << 2, true)
		};
	},
	function literalRegExp(position, buffer): ast.LiteralRegExp {
		const flags = buffer.convertString(buffer[position + 2]);
		const pattern = buffer.convertString(buffer[position + 3]);
		return {
			type: 'Literal',
			start: buffer[position],
			end: buffer[position + 1],
			raw: `/${pattern}/${flags}`,
			regex: { flags, pattern },
			value: new RegExp(pattern, flags)
		};
	},
	function literalString(position, buffer): ast.LiteralString {
		const rawPosition = buffer[position + 3];
		return {
			type: 'Literal',
			start: buffer[position],
			end: buffer[position + 1],
			value: buffer.convertString(buffer[position + 2]),
			raw: rawPosition === 0 ? undefined : buffer.convertString(rawPosition)
		};
	},
	function logicalExpression(position, buffer): ast.LogicalExpression {
		return {
			type: 'LogicalExpression',
			start: buffer[position],
			end: buffer[position + 1],
			operator: FIXED_STRINGS[buffer[position + 2]] as ast.LogicalExpression['operator'],
			left: convertNode(buffer[position + 3], buffer),
			right: convertNode(buffer[position + 4], buffer)
		};
	},
	function memberExpression(position, buffer): ast.MemberExpression {
		const flags = buffer[position + 2];
		return {
			type: 'MemberExpression',
			start: buffer[position],
			end: buffer[position + 1],
			computed: (flags & 1) === 1,
			optional: (flags & 2) === 2,
			object: convertNode(buffer[position + 3], buffer),
			property: convertNode(buffer[position + 4], buffer)
		};
	},
	function metaProperty(position, buffer): ast.MetaProperty {
		return {
			type: 'MetaProperty',
			start: buffer[position],
			end: buffer[position + 1],
			meta: convertNode(buffer[position + 2], buffer),
			property: convertNode(buffer[position + 3], buffer)
		};
	},
	function methodDefinition(position, buffer): ast.MethodDefinition {
		const flags = buffer[position + 2];
		return {
			type: 'MethodDefinition',
			start: buffer[position],
			end: buffer[position + 1],
			static: (flags & 1) === 1,
			computed: (flags & 2) === 2,
			decorators: convertNodeList(buffer[position + 3], buffer),
			key: convertNode(buffer[position + 4], buffer),
			value: convertNode(buffer[position + 5], buffer),
			kind: FIXED_STRINGS[buffer[position + 6]] as ast.MethodDefinition['kind']
		};
	},
	function newExpression(position, buffer): ast.NewExpression {
		const annotations = convertAnnotations(buffer[position + 2], buffer);
		return {
			type: 'NewExpression',
			start: buffer[position],
			end: buffer[position + 1],
			...(annotations.length > 0 ? { annotations } : {}),
			callee: convertNode(buffer[position + 3], buffer),
			arguments: convertNodeList(buffer[position + 4], buffer)
		};
	},
	function objectExpression(position, buffer): ast.ObjectExpression {
		return {
			type: 'ObjectExpression',
			start: buffer[position],
			end: buffer[position + 1],
			properties: convertNodeList(buffer[position + 2], buffer)
		};
	},
	function objectPattern(position, buffer): ast.ObjectPattern {
		return {
			type: 'ObjectPattern',
			start: buffer[position],
			end: buffer[position + 1],
			properties: convertNodeList(buffer[position + 2], buffer)
		};
	},
	function privateIdentifier(position, buffer): ast.PrivateIdentifier {
		return {
			type: 'PrivateIdentifier',
			start: buffer[position],
			end: buffer[position + 1],
			name: buffer.convertString(buffer[position + 2])
		};
	},
	function program(position, buffer): ast.Program {
		const invalidAnnotations = convertAnnotations(buffer[position + 3], buffer);
		return {
			type: 'Program',
			start: buffer[position],
			end: buffer[position + 1],
			body: convertNodeList(buffer[position + 2], buffer),
			...(invalidAnnotations.length > 0 ? { invalidAnnotations } : {}),
			sourceType: 'module'
		};
	},
	function property(position, buffer): ast.Property {
		const flags = buffer[position + 2];
		const keyPosition = buffer[position + 3];
		const value = convertNode(buffer[position + 4], buffer);
		return {
			type: 'Property',
			start: buffer[position],
			end: buffer[position + 1],
			method: (flags & 1) === 1,
			shorthand: (flags & 2) === 2,
			computed: (flags & 4) === 4,
			key: keyPosition === 0 ? { ...value } : convertNode(keyPosition, buffer),
			value,
			kind: FIXED_STRINGS[buffer[position + 5]] as ast.Property['kind']
		};
	},
	function propertyDefinition(position, buffer): ast.PropertyDefinition {
		const flags = buffer[position + 2];
		const valuePosition = buffer[position + 5];
		return {
			type: 'PropertyDefinition',
			start: buffer[position],
			end: buffer[position + 1],
			static: (flags & 1) === 1,
			computed: (flags & 2) === 2,
			decorators: convertNodeList(buffer[position + 3], buffer),
			key: convertNode(buffer[position + 4], buffer),
			value: valuePosition === 0 ? null : convertNode(valuePosition, buffer)
		};
	},
	function restElement(position, buffer): ast.RestElement {
		return {
			type: 'RestElement',
			start: buffer[position],
			end: buffer[position + 1],
			argument: convertNode(buffer[position + 2], buffer)
		};
	},
	function returnStatement(position, buffer): ast.ReturnStatement {
		const argumentPosition = buffer[position + 2];
		return {
			type: 'ReturnStatement',
			start: buffer[position],
			end: buffer[position + 1],
			argument: argumentPosition === 0 ? null : convertNode(argumentPosition, buffer)
		};
	},
	function sequenceExpression(position, buffer): ast.SequenceExpression {
		return {
			type: 'SequenceExpression',
			start: buffer[position],
			end: buffer[position + 1],
			expressions: convertNodeList(buffer[position + 2], buffer)
		};
	},
	function spreadElement(position, buffer): ast.SpreadElement {
		return {
			type: 'SpreadElement',
			start: buffer[position],
			end: buffer[position + 1],
			argument: convertNode(buffer[position + 2], buffer)
		};
	},
	function staticBlock(position, buffer): ast.StaticBlock {
		return {
			type: 'StaticBlock',
			start: buffer[position],
			end: buffer[position + 1],
			body: convertNodeList(buffer[position + 2], buffer)
		};
	},
	function superElement(position, buffer): ast.Super {
		return {
			type: 'Super',
			start: buffer[position],
			end: buffer[position + 1]
		};
	},
	function switchCase(position, buffer): ast.SwitchCase {
		const testPosition = buffer[position + 2];
		return {
			type: 'SwitchCase',
			start: buffer[position],
			end: buffer[position + 1],
			test: testPosition === 0 ? null : convertNode(testPosition, buffer),
			consequent: convertNodeList(buffer[position + 3], buffer)
		};
	},
	function switchStatement(position, buffer): ast.SwitchStatement {
		return {
			type: 'SwitchStatement',
			start: buffer[position],
			end: buffer[position + 1],
			discriminant: convertNode(buffer[position + 2], buffer),
			cases: convertNodeList(buffer[position + 3], buffer)
		};
	},
	function taggedTemplateExpression(position, buffer): ast.TaggedTemplateExpression {
		return {
			type: 'TaggedTemplateExpression',
			start: buffer[position],
			end: buffer[position + 1],
			tag: convertNode(buffer[position + 2], buffer),
			quasi: convertNode(buffer[position + 3], buffer)
		};
	},
	function templateElement(position, buffer): ast.TemplateElement {
		const flags = buffer[position + 2];
		const cookedPosition = buffer[position + 3];
		const cooked = cookedPosition === 0 ? undefined : buffer.convertString(cookedPosition);
		const raw = buffer.convertString(buffer[position + 4]);
		return {
			type: 'TemplateElement',
			start: buffer[position],
			end: buffer[position + 1],
			tail: (flags & 1) === 1,
			value: { cooked, raw }
		};
	},
	function templateLiteral(position, buffer): ast.TemplateLiteral {
		return {
			type: 'TemplateLiteral',
			start: buffer[position],
			end: buffer[position + 1],
			quasis: convertNodeList(buffer[position + 2], buffer),
			expressions: convertNodeList(buffer[position + 3], buffer)
		};
	},
	function thisExpression(position, buffer): ast.ThisExpression {
		return {
			type: 'ThisExpression',
			start: buffer[position],
			end: buffer[position + 1]
		};
	},
	function throwStatement(position, buffer): ast.ThrowStatement {
		return {
			type: 'ThrowStatement',
			start: buffer[position],
			end: buffer[position + 1],
			argument: convertNode(buffer[position + 2], buffer)
		};
	},
	function tryStatement(position, buffer): ast.TryStatement {
		const handlerPosition = buffer[position + 3];
		const finalizerPosition = buffer[position + 4];
		return {
			type: 'TryStatement',
			start: buffer[position],
			end: buffer[position + 1],
			block: convertNode(buffer[position + 2], buffer),
			handler: handlerPosition === 0 ? null : convertNode(handlerPosition, buffer),
			finalizer: finalizerPosition === 0 ? null : convertNode(finalizerPosition, buffer)
		};
	},
	function unaryExpression(position, buffer): ast.UnaryExpression {
		return {
			type: 'UnaryExpression',
			start: buffer[position],
			end: buffer[position + 1],
			operator: FIXED_STRINGS[buffer[position + 2]] as ast.UnaryExpression['operator'],
			argument: convertNode(buffer[position + 3], buffer),
			prefix: true
		};
	},
	function updateExpression(position, buffer): ast.UpdateExpression {
		const flags = buffer[position + 2];
		return {
			type: 'UpdateExpression',
			start: buffer[position],
			end: buffer[position + 1],
			prefix: (flags & 1) === 1,
			operator: FIXED_STRINGS[buffer[position + 3]] as ast.UpdateExpression['operator'],
			argument: convertNode(buffer[position + 4], buffer)
		};
	},
	function variableDeclaration(position, buffer): ast.VariableDeclaration {
		return {
			type: 'VariableDeclaration',
			start: buffer[position],
			end: buffer[position + 1],
			kind: FIXED_STRINGS[buffer[position + 2]] as ast.VariableDeclaration['kind'],
			declarations: convertNodeList(buffer[position + 3], buffer)
		};
	},
	function variableDeclarator(position, buffer): ast.VariableDeclarator {
		const initPosition = buffer[position + 3];
		return {
			type: 'VariableDeclarator',
			start: buffer[position],
			end: buffer[position + 1],
			id: convertNode(buffer[position + 2], buffer),
			init: initPosition === 0 ? null : convertNode(initPosition, buffer)
		};
	},
	function whileStatement(position, buffer): ast.WhileStatement {
		return {
			type: 'WhileStatement',
			start: buffer[position],
			end: buffer[position + 1],
			test: convertNode(buffer[position + 2], buffer),
			body: convertNode(buffer[position + 3], buffer)
		};
	},
	function yieldExpression(position, buffer): ast.YieldExpression {
		const flags = buffer[position + 2];
		const argumentPosition = buffer[position + 3];
		return {
			type: 'YieldExpression',
			start: buffer[position],
			end: buffer[position + 1],
			delegate: (flags & 1) === 1,
			argument: argumentPosition === 0 ? null : convertNode(argumentPosition, buffer)
		};
	}
];

export function convertNode(position: number, buffer: AstBuffer): any {
	const nodeType = buffer[position];
	const converter = nodeConverters[nodeType];
	/* istanbul ignore if: This should never be executed but is a safeguard against faulty buffers */
	if (!converter) {
		console.trace();
		throw new Error(`Unknown node type: ${nodeType}`);
	}
	return converter(position + 1, buffer);
}

function convertNodeList(position: number, buffer: AstBuffer): any[] {
	if (position === 0) return EMPTY_ARRAY as never[];
	const length = buffer[position++];
	const list: any[] = new Array(length);
	for (let index = 0; index < length; index++) {
		const nodePosition = buffer[position++];
		list[index] = nodePosition ? convertNode(nodePosition, buffer) : null;
	}
	return list;
}
